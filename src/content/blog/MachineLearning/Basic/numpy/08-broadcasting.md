---
title: NumPy 广播机制
date: 2026-01-07
category: MachineLearning/Basic/numpy
tags:
  - Python
  - NumPy
description: 理解 NumPy 广播规则，高效处理不同形状数组间的运算
image: https://img.yumeko.site/file/blog/NumpyLearning.jpg
status: public
---

# 广播机制

## 学习目标

- 理解 NumPy 的广播机制
- 掌握广播的规则和原理
- 学会利用广播进行高效运算

## 什么是广播？

**广播（Broadcasting）** 是 NumPy 中一个强大的机制，允许不同形状的数组进行算术运算。NumPy 会自动"扩展"较小的数组，使其与较大数组形状兼容。

**通俗理解**：当两个形状不同的数组运算时，NumPy 会"聪明地"把小数组复制多份来匹配大数组。

```python
# 没有广播，这样做会报错
[1, 2, 3] + 10  # Python 列表不支持

# 有了广播，这样做就可以
np.array([1, 2, 3]) + 10  # [11, 12, 13]
```

## 广播规则

NumPy 按以下规则判断两个数组是否可以广播：

1. **从后向前**比较每个维度的大小
2. 维度大小**相同**或其中一个为 **1** 时可以广播
3. **缺失的维度**视为 1

### 广播规则图解

```
比较方向: ← ← ←
数组 A: (  3, 4)
数组 B: (     4)  ← 缺失的维度视为 1，即 (1, 4)
结果:   (  3, 4)  ✓ 可以广播
```

### 广播示例

```
数组 A: (3, 4)    数组 B: (4,)     → 结果: (3, 4)  ✓
数组 A: (3, 4)    数组 B: (3, 1)   → 结果: (3, 4)  ✓
数组 A: (3, 1)    数组 B: (1, 4)   → 结果: (3, 4)  ✓
数组 A: (3, 4)    数组 B: (3,)     → 错误！无法广播 ✗
```

**最后一个为什么失败？**

```
数组 A: (3, 4)  → 最后一维是 4
数组 B: (3,)    → 最后一维是 3
4 ≠ 3 且都不是 1，无法广播！
```

## 标量与数组广播

最简单的广播：标量与数组运算。

```python
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# 标量广播到所有元素
print(arr + 10)
```

**结果**：

```
[[11 12 13]
 [14 15 16]
 [17 18 19]]
```

**过程可视化**：

```
原数组:          标量 10 广播后:      结果:
[[1 2 3]         [[10 10 10]       [[11 12 13]
 [4 5 6]    +     [10 10 10]   =    [14 15 16]
 [7 8 9]]         [10 10 10]]       [17 18 19]]
```

```python
print(arr * 2)
```

**结果**：

```
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]
```

## 一维与二维数组广播

```python
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])  # (3, 3)
arr_1d = np.array([10, 20, 30])  # (3,)

result = arr_2d + arr_1d
print(result)
```

**结果**：

```
[[11 22 33]
 [14 25 36]
 [17 28 39]]
```

**广播过程**：

```
arr_2d (3, 3):       arr_1d (3,) → (1, 3) → (3, 3):
[[1 2 3]             [[10 20 30]
 [4 5 6]              [10 20 30]    (复制 3 行)
 [7 8 9]]             [10 20 30]]
```

**计算**：每行都加上 `[10, 20, 30]`。

## 列向量广播

如果想让每列加上不同的值，需要把一维数组变成列向量。

```python
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])  # (3, 3)

# 创建列向量 (3, 1)
col = np.array([[100], [200], [300]])

result = arr_2d + col
print(result)
```

**结果**：

```
[[101 102 103]
 [204 205 206]
 [307 308 309]]
```

**广播过程**：

```
arr_2d (3, 3):       col (3, 1) → (3, 3):
[[1 2 3]             [[100 100 100]
 [4 5 6]              [200 200 200]    (每行复制 3 列)
 [7 8 9]]             [300 300 300]]
```

**计算**：第一行加 100，第二行加 200，第三行加 300。

## 广播可视化

```
行向量广播:
数组 A (3, 3):         一维数组 B (3,):
[[1, 2, 3],            [10, 20, 30]
 [4, 5, 6],                ↓ 广播为 (3, 3)
 [7, 8, 9]]            [[10, 20, 30],
                        [10, 20, 30],
                        [10, 20, 30]]

列向量广播:
数组 A (3, 3):         列向量 B (3, 1):
[[1, 2, 3],            [[100],      → 广播为 (3, 3):
 [4, 5, 6],             [200],      [[100, 100, 100],
 [7, 8, 9]]             [300]]       [200, 200, 200],
                                     [300, 300, 300]]
```

## 利用广播实现外积

外积：两个向量生成一个矩阵。

```python
a = np.array([1, 2, 3])        # (3,)
b = np.array([10, 20, 30, 40]) # (4,)

# 方法 1: 利用广播
# a 变成 (3, 1)，b 是 (4,) → (1, 4)
# (3, 1) * (1, 4) → (3, 4)
outer = a[:, np.newaxis] * b
print(outer)
```

**结果**：

```
[[ 10  20  30  40]
 [ 20  40  60  80]
 [ 30  60  90 120]]
```

**过程**：

```
a (3, 1):      b (1, 4):              结果 (3, 4):
[[1]           [[10, 20, 30, 40]]     [[1×10, 1×20, 1×30, 1×40]
 [2]      ×     (广播后每行相同)  →    [2×10, 2×20, 2×30, 2×40]
 [3]]                                  [3×10, 3×20, 3×30, 3×40]]
```

```python
# 方法 2: 使用 np.outer
result = np.outer(a, b)  # 结果相同
```

## 实际应用：数据标准化

标准化是机器学习中最常用的预处理步骤，广播让它变得非常简洁。

```python
# 原始数据 (5 个样本, 3 个特征)
np.random.seed(42)
data = np.random.randint(0, 100, size=(5, 3))
print("原始数据:\n", data)
```

**结果**：

```
原始数据:
 [[51 92 14]
  [71 60 20]
  [82 86 74]
  [74 87 99]
  [23  2 21]]
```

```python
# 计算每列的均值和标准差
mean = data.mean(axis=0)  # (3,)
std = data.std(axis=0)    # (3,)

print("均值:", mean)
print("标准差:", std)
```

**结果**：

```
均值: [60.2 65.4 45.6]
标准差: [20.95 32.71 33.46]
```

```python
# 标准化（利用广播）
# data 是 (5, 3)，mean 和 std 都是 (3,)
# 广播后，每列减去该列的均值，除以该列的标准差
normalized = (data - mean) / std

print("标准化后:\n", normalized.round(2))
```

**结果**：

```
标准化后:
 [[-0.44  0.81 -0.94]
  [ 0.52 -0.16 -0.77]
  [ 1.04  0.63  0.85]
  [ 0.66  0.66  1.6 ]
  [-1.78 -1.94 -0.74]]
```

**验证**：

```python
print("标准化后均值:", normalized.mean(axis=0).round(10))  # 接近 [0, 0, 0]
print("标准化后标准差:", normalized.std(axis=0).round(2))  # 接近 [1, 1, 1]
```

## 广播的优势

1. **代码简洁**：不需要手动循环或复制数组
2. **运算高效**：NumPy 内部优化，不会真的复制数据
3. **内存节省**：小数组不会真的扩展成大数组
4. **表达直观**：数学表达式直接映射为代码

**对比**：

```python
# 不用广播（慢，代码冗长）
result = np.zeros((3, 4))
for i in range(3):
    for j in range(4):
        result[i, j] = arr[i, j] + row[j]

# 用广播（快，代码简洁）
result = arr + row
```

## 常见错误

```python
A = np.ones((3, 4))
B = np.ones((3,))    # 形状 (3,) 而非 (4,)

A + B  # 错误！ValueError
```

**错误原因**：

```
A: (3, 4)  → 最后一维是 4
B: (3,)    → 最后一维是 3
4 ≠ 3 且都不是 1，无法广播！
```

**解决方法**：

```python
# 把 B 变成 (3, 1)，然后可以广播
A + B[:, np.newaxis]  # ✓
```

## 广播兼容性速查

| 形状 A    | 形状 B    | 结果形状  | 是否兼容 |
| --------- | --------- | --------- | -------- |
| (3,)      | (3,)      | (3,)      | ✓        |
| (3, 4)    | (4,)      | (3, 4)    | ✓        |
| (3, 4)    | (3, 1)    | (3, 4)    | ✓        |
| (3, 1)    | (1, 4)    | (3, 4)    | ✓        |
| (3, 4)    | (3,)      | 错误      | ✗        |
| (2, 3, 4) | (3, 4)    | (2, 3, 4) | ✓        |
| (2, 3, 4) | (2, 1, 4) | (2, 3, 4) | ✓        |

## 小结

1. **广播本质**：让不同形状的数组可以进行运算
2. **广播规则**：从后向前比较，相同或为 1 可广播
3. **行向量广播**：(3,) 对 (3, 4) 会按行复制
4. **列向量广播**：(3, 1) 对 (3, 4) 会按列复制
5. **实际应用**：数据标准化、批量计算

## 练习

运行代码文件查看完整演示：

```bash
python Basic/Numpy/08_broadcasting.py
```

**练习题**：

1. 创建 (4, 3) 矩阵，给每行加上 `[1, 2, 3]`
2. 创建 (4, 3) 矩阵，给每列加上 `[10, 20, 30, 40]`（需要先变成列向量）
3. 判断以下哪些可以广播：(5, 3) 和 (3,)? (5, 3) 和 (5,)? (5, 1, 3) 和 (4, 1)?
