---
title: NumPy 全指南
date: 2026-01-11
category: MachineLearning/Basic
tags:
  - Python
  - NumPy
description: 一个全面的 NumPy 学习教程，涵盖从基础到高级的所有核心概念，包括数组创建、索引切片、数学运算、线性代数、广播机制、文件操作等，包含大量代码示例和实战项目。
image: https://img.yumeko.site/file/blog/NumpyLearning.jpg
status: published
---

# NumPy 基础入门

## 学习目标

- 了解什么是 NumPy 及其重要性
- 掌握 NumPy 的安装和导入方法
- 理解 NumPy 与 Python 列表的区别

## 什么是 NumPy

NumPy（Numerical Python）是 Python 科学计算的基础库，提供：

- 高性能的多维数组对象 `ndarray`
- 丰富的数学函数库
- 线性代数、傅里叶变换、随机数生成等功能
- 与 C/C++ 和 Fortran 代码集成的工具

### 为什么 NumPy 如此重要？

想象一下，你需要对 100 万个数字进行计算。使用 Python 列表，你需要写循环逐个处理，这会非常慢。而 NumPy 的数组可以一次性对所有元素进行操作（称为"向量化"），速度提升 10-100 倍。

**通俗理解**：如果 Python 列表像是一个个独立的盒子，每次操作只能打开一个盒子；那么 NumPy 数组就像是一个大型仓库，可以同时处理所有物品。

## 为什么学习 NumPy

| 优势             | 说明                                              |
| ---------------- | ------------------------------------------------- |
| **性能优势**     | 底层使用 C 语言实现，比纯 Python 快 10-100 倍     |
| **内存效率**     | 连续内存存储，支持向量化操作                      |
| **生态基础**     | Pandas、Scikit-learn、TensorFlow 等库都基于 NumPy |
| **科学计算标准** | 数据科学和机器学习的必备技能                      |

## 安装和导入

```python
# 安装（在命令行执行）
pip install numpy

# 导入（约定使用 np 别名）
import numpy as np

# 查看版本
print(np.__version__)
```

**为什么用 `np` 别名？** 这是社区约定俗成的写法，几乎所有 NumPy 教程和代码都这样写。使用别名可以让代码更简洁，`np.array()` 比 `numpy.array()` 更方便输入。

**运行结果示例**：

```
1.24.0
```

版本号可能不同，只要是 1.x 版本就可以正常使用本教程的所有代码。

## NumPy 数组 vs Python 列表

| 特性         | NumPy 数组               | Python 列表            |
| ------------ | ------------------------ | ---------------------- |
| **数据类型** | 同质（所有元素类型相同） | 异质（可包含不同类型） |
| **内存**     | 连续存储，效率高         | 分散存储，效率低       |
| **运算**     | 支持向量化运算           | 需要循环遍历           |
| **速度**     | 快（C 实现）             | 慢（Python 实现）      |

### 运算行为对比

这是 NumPy 和 Python 列表最重要的区别之一：

```python
# Python 列表
py_list = [1, 2, 3, 4, 5]
result = py_list * 2
print(result)
```

**结果**：`[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]`

**原理**：Python 列表的 `*` 运算符表示"重复"，所以 `列表 * 2` 会把列表复制两遍拼接在一起。

```python
# NumPy 数组
np_array = np.array([1, 2, 3, 4, 5])
result = np_array * 2
print(result)
```

**结果**：`[2, 4, 6, 8, 10]`

**原理**：NumPy 数组的 `*` 运算符表示"元素级乘法"，会把每个元素都乘以 2。这就是"向量化操作"的体现——一行代码完成对所有元素的计算，无需循环。

### 加法行为对比

```python
# Python 列表加法 = 拼接
[1, 2, 3] + [4, 5, 6]  # 结果: [1, 2, 3, 4, 5, 6]

# NumPy 数组加法 = 元素相加
np.array([1, 2, 3]) + np.array([4, 5, 6])  # 结果: [5, 7, 9]
```

## 重要概念

| 概念           | 说明                                          |
| -------------- | --------------------------------------------- |
| **ndarray**    | NumPy 的多维数组对象，是 NumPy 的核心数据结构 |
| **向量化操作** | 对整个数组进行操作，无需显式循环              |
| **广播**       | 不同形状数组之间的运算规则                    |

### ndarray 是什么？

`ndarray` 是 "N-dimensional array" 的缩写，意思是"N维数组"。

- 1 维数组：`[1, 2, 3, 4, 5]` — 像一条直线上的点
- 2 维数组：`[[1,2,3], [4,5,6]]` — 像一个表格（行和列）
- 3 维数组：可以想象成多个表格叠在一起

### 向量化操作的优势

**传统 Python 写法**（慢）：

```python
result = []
for i in range(len(py_list)):
    result.append(py_list[i] * 2)
```

**NumPy 向量化写法**（快）：

```python
result = np_array * 2
```

两种写法结果相同，但 NumPy 的写法不仅代码更简洁，执行速度也快得多。

## 常用配置函数

```python
# 设置打印选项
np.set_printoptions(precision=4, suppress=True)
```

**参数说明**：

- `precision=4`：浮点数只显示 4 位小数
- `suppress=True`：禁用科学计数法显示

**使用场景**：当你看到 `1.23456789e-05` 这样的科学计数法觉得不直观时，可以设置 `suppress=True` 让它显示为 `0.0000`。

```python
# 查看当前打印设置
print(np.get_printoptions())
```

**结果**：返回一个字典，包含所有当前的打印设置项。

## 小结

1. **NumPy 是什么**：Python 科学计算的核心库，提供高效的多维数组
2. **为什么用它**：比 Python 列表快 10-100 倍，是数据科学的基础
3. **核心区别**：NumPy 数组的运算是"元素级"的，Python 列表的运算是"整体操作"
4. **关键概念**：ndarray、向量化、广播

## 练习
1. 创建一个包含 1-10 的 NumPy 数组，然后将所有元素加 100
2. 比较 `np.array([1,2,3]) + 10` 和 `[1,2,3] + [10]` 的结果，理解它们的区别

# 数组创建

## 学习目标

- 掌握各种创建 NumPy 数组的方法
- 理解不同创建方法的适用场景
- 学会创建特殊类型的数组

## 创建方法一览

| 方法                  | 说明                 | 示例                            |
| --------------------- | -------------------- | ------------------------------- |
| `np.array()`          | 从列表创建数组       | `np.array([1,2,3])`             |
| `np.zeros()`          | 创建全零数组         | `np.zeros((3,4))`               |
| `np.ones()`           | 创建全一数组         | `np.ones((2,3))`                |
| `np.eye()`            | 创建单位矩阵         | `np.eye(3)`                     |
| `np.full()`           | 创建填充指定值的数组 | `np.full((2,2), 7)`             |
| `np.arange()`         | 创建等差数列         | `np.arange(0, 10, 2)`           |
| `np.linspace()`       | 创建等间距数列       | `np.linspace(0, 1, 5)`          |
| `np.random.rand()`    | 创建 0-1 随机数组    | `np.random.rand(2,3)`           |
| `np.random.randint()` | 创建随机整数数组     | `np.random.randint(0,10,(3,3))` |

## 从列表创建 (np.array)

`np.array()` 是最基本的创建方法，可以把 Python 列表转换成 NumPy 数组。

```python
# 一维数组
arr_1d = np.array([1, 2, 3, 4, 5])
print(arr_1d)
```

**结果**：`[1 2 3 4 5]`

**注意**：NumPy 数组打印时元素之间没有逗号，这是区分它和 Python 列表的一个标志。

```python
# 二维数组
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])
print(arr_2d)
```

**结果**：

```
[[1 2 3]
 [4 5 6]]
```

**原理**：传入嵌套列表，NumPy 会自动识别为二维数组。外层列表的每个元素代表一行。

```python
# 指定数据类型
arr_float = np.array([1, 2, 3], dtype=np.float64)
print(arr_float)
```

**结果**：`[1. 2. 3.]`

**说明**：注意数字后面的小数点，表示这是浮点数。`dtype` 参数可以强制指定数据类型。

### 参数说明

| 参数     | 说明                                      |
| -------- | ----------------------------------------- |
| `object` | 输入数据，可以是列表、元组等可迭代对象    |
| `dtype`  | 指定数据类型，如 `np.int32`、`np.float64` |
| `copy`   | 是否复制数据，默认 True                   |

## 特殊数组

### 全零数组 (np.zeros)

**使用场景**：初始化数组，准备后续填充数据；创建占位符数组。

```python
# 3x4 全零数组
arr = np.zeros((3, 4))
print(arr)
```

**结果**：

```
[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
```

**注意**：参数是一个元组 `(3, 4)`，不是两个参数 `3, 4`。这是初学者常犯的错误。

```python
# 一维全零数组
np.zeros(5)  # 结果: [0. 0. 0. 0. 0.]

# 三维全零数组
np.zeros((2, 3, 4))  # 形状: 2个 3x4 的矩阵
```

### 全一数组 (np.ones)

**使用场景**：创建掩码数组、初始化权重等。

```python
# 2x3 全一数组
arr = np.ones((2, 3))
print(arr)
```

**结果**：

```
[[1. 1. 1.]
 [1. 1. 1.]]
```

```python
# 整数类型的全一数组
arr_int = np.ones(5, dtype=int)
print(arr_int)
```

**结果**：`[1 1 1 1 1]`

**说明**：默认是浮点数 `1.`，加上 `dtype=int` 可以创建整数数组 `1`。

### 单位矩阵 (np.eye)

**什么是单位矩阵？** 单位矩阵是对角线上全为 1，其他位置全为 0 的方阵。在线性代数中，任何矩阵乘以单位矩阵等于它自己（类似于数字乘以 1）。

```python
# 3x3 单位矩阵
arr = np.eye(3)
print(arr)
```

**结果**：

```
[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]
```

```python
# 上对角线偏移 1
np.eye(3, k=1)
```

**结果**：

```
[[0. 1. 0.]
 [0. 0. 1.]
 [0. 0. 0.]]
```

**原理**：`k=1` 表示对角线向上移动 1 位，`k=-1` 表示向下移动。

### 填充数组 (np.full)

**使用场景**：需要用特定值初始化数组时。

```python
# 2x2 数组，全部填充 7
arr = np.full((2, 2), 7)
print(arr)
```

**结果**：

```
[[7 7]
 [7 7]]
```

```python
# 用 π 填充
arr_pi = np.full((3, 3), np.pi)
print(arr_pi)
```

**结果**：

```
[[3.14159265 3.14159265 3.14159265]
 [3.14159265 3.14159265 3.14159265]
 [3.14159265 3.14159265 3.14159265]]
```

## 序列数组

### 等差数列 (np.arange)

**原理**：类似 Python 的 `range()`，但返回的是 NumPy 数组，且支持浮点数。

```python
# 基本用法：0 到 9
arr = np.arange(10)
print(arr)
```

**结果**：`[0 1 2 3 4 5 6 7 8 9]`

```python
# 指定起点和终点
np.arange(1, 10)    # 结果: [1 2 3 4 5 6 7 8 9]

# 指定步长
np.arange(1, 10, 2) # 结果: [1 3 5 7 9]

# 倒序
np.arange(10, 0, -1) # 结果: [10 9 8 7 6 5 4 3 2 1]
```

**重要**：`arange` 不包含终点！`np.arange(1, 10)` 生成 1-9，不包含 10。

### 等间距数列 (np.linspace)

**原理**：指定起点、终点和元素个数，自动计算步长。

```python
# 0 到 1 之间的 5 个等间距点
arr = np.linspace(0, 1, 5)
print(arr)
```

**结果**：`[0.   0.25 0.5  0.75 1.  ]`

**计算过程**：

- 起点 0，终点 1
- 需要 5 个点
- 间隔 = (1-0) / (5-1) = 0.25
- 结果：0, 0.25, 0.5, 0.75, 1.0

```python
# 用于绑图的典型用法
x = np.linspace(0, 2*np.pi, 100)  # 0 到 2π 的 100 个点
```

**使用场景**：绑制平滑曲线时，用 `linspace` 创建 x 轴坐标点。

```python
# 不包含终点
np.linspace(0, 1, 5, endpoint=False)
```

**结果**：`[0.  0.2 0.4 0.6 0.8]`

> **arange vs linspace**：
>
> - `arange` 需要指定步长，可能会因浮点精度问题导致元素个数不确定
> - `linspace` 需要指定点数，元素个数精确可控
> - 绑图时推荐使用 `linspace`

## 随机数组

### 设置随机种子

**为什么要设置随机种子？** 让随机结果可复现。调试代码时，希望每次运行得到相同的"随机"数据。

```python
np.random.seed(42)  # 42 是一个常用的种子值
```

**原理**：计算机生成的是"伪随机数"，由种子值决定随机序列。相同的种子产生相同的随机数序列。

### 均匀分布

```python
np.random.seed(42)
arr = np.random.rand(2, 3)
print(arr)
```

**结果**：

```
[[0.37454012 0.95071431 0.73199394]
 [0.59865848 0.15601864 0.15599452]]
```

**原理**：`rand()` 生成 [0, 1) 区间的均匀分布随机数。每个数在 0 到 1 之间出现的概率相同。

### 随机整数

```python
np.random.seed(42)
arr = np.random.randint(0, 10, (3, 3))
print(arr)
```

**结果**：

```
[[6 3 7]
 [4 6 9]
 [2 6 7]]
```

**参数说明**：

- `0`：最小值（包含）
- `10`：最大值（不包含）
- `(3, 3)`：数组形状

**结果范围**：0, 1, 2, ..., 9（不包含 10）

### 正态分布

```python
# 标准正态分布 (均值=0, 标准差=1)
arr = np.random.randn(5)
print(arr)
```

**结果示例**：`[-0.13826344  0.6536186   0.8644362  -0.74216502  2.26975462]`

**原理**：正态分布（高斯分布）是自然界最常见的分布，如人的身高、考试成绩等。大部分值集中在均值附近，离均值越远，出现概率越低。

```python
# 指定均值和标准差
arr = np.random.normal(loc=100, scale=15, size=5)
print(arr)
```

**结果示例**：`[98.2  115.3  107.8  89.5  102.1]`

**应用场景**：模拟 IQ 分数（均值 100，标准差 15）

## 随机函数对比

| 函数                 | 分布             | 范围                   |
| -------------------- | ---------------- | ---------------------- |
| `rand()`             | 均匀分布         | [0, 1)                 |
| `random()`           | 均匀分布         | [0, 1)                 |
| `randint(low, high)` | 均匀分布（整数） | [low, high)            |
| `randn()`            | 标准正态分布     | (-∞, +∞)               |
| `normal(loc, scale)` | 正态分布         | 均值 loc，标准差 scale |

## 小结

1. **从已有数据创建**：`np.array()` — 把列表转成数组
2. **创建特殊数组**：`zeros`、`ones`、`eye`、`full` — 初始化用
3. **创建序列**：`arange`（指定步长）、`linspace`（指定个数）
4. **创建随机数组**：`rand`、`randint`、`randn` — 模拟和测试用

## 练习
1. 创建一个 5x5 的单位矩阵
2. 创建一个 0 到 100 之间（包含 100）的 11 个等间距整数
3. 创建一个 3x4 的随机整数矩阵，值范围在 1-6（模拟掷骰子）

# 数组属性

## 学习目标

- 掌握 NumPy 数组的重要属性
- 理解数组形状、维度、数据类型等概念
- 学会查看和修改数组属性

## 为什么要了解数组属性？

在数据处理中，你经常需要回答这些问题：

- 这个数组有多少行多少列？（`shape`）
- 这个数组是几维的？（`ndim`）
- 总共有多少个数据？（`size`）
- 数据是什么类型？（`dtype`）
- 占用多少内存？（`nbytes`）

这些属性帮助你快速了解数据的"规格"，是数据探索的第一步。

## 重要属性一览

| 属性       | 说明                     | 示例结果  |
| ---------- | ------------------------ | --------- |
| `shape`    | 数组的形状（各维度大小） | `(3, 4)`  |
| `ndim`     | 数组的维度数             | `2`       |
| `size`     | 数组的元素总数           | `12`      |
| `dtype`    | 数组的数据类型           | `float64` |
| `itemsize` | 每个元素的字节大小       | `8`       |
| `nbytes`   | 数组总字节数             | `96`      |

## 形状属性

### shape - 数组的形状

`shape` 是最常用的属性，返回一个元组，表示数组在每个维度上的大小。

```python
arr = np.random.random((3, 4))
print(arr.shape)
```

**结果**：`(3, 4)`

**含义**：这是一个 3 行 4 列的二维数组。

```python
# 获取行数和列数
print(arr.shape[0])   # 3 (行数)
print(arr.shape[1])   # 4 (列数)
```

**实用技巧**：在机器学习中，`shape[0]` 通常表示样本数，`shape[1]` 表示特征数。

### ndim - 维度数

```python
arr_1d = np.array([1, 2, 3])
arr_2d = np.array([[1, 2], [3, 4]])
arr_3d = np.zeros((2, 3, 4))

print(arr_1d.ndim)  # 1
print(arr_2d.ndim)  # 2
print(arr_3d.ndim)  # 3
```

**理解维度**：

- 1 维：一条线（向量）
- 2 维：一个面（矩阵/表格）
- 3 维：一个立体（如彩色图片：高度 × 宽度 × 颜色通道）

### size - 元素总数

```python
arr = np.random.random((3, 4))
print(arr.size)  # 12
```

**结果**：`12`

**计算方式**：`size = shape[0] × shape[1] = 3 × 4 = 12`

**与 len() 的区别**：

```python
print(len(arr))   # 3 (只返回第一维的长度)
print(arr.size)   # 12 (返回所有元素的总数)
```

## 内存属性

### dtype - 数据类型

```python
arr = np.random.random((3, 4))
print(arr.dtype)  # float64
```

**结果**：`float64`

**含义**：每个元素是 64 位（8 字节）的浮点数。

```python
arr_int = np.array([1, 2, 3])
print(arr_int.dtype)  # int32 或 int64（取决于系统）
```

### itemsize - 每个元素的字节数

```python
arr_float = np.array([1.0, 2.0, 3.0])
print(arr_float.itemsize)  # 8
```

**结果**：`8`

**含义**：float64 类型每个元素占用 8 字节（64 位 ÷ 8 = 8 字节）。

```python
arr_int32 = np.array([1, 2, 3], dtype=np.int32)
print(arr_int32.itemsize)  # 4
```

### nbytes - 总字节数

```python
arr = np.random.random((3, 4))
print(arr.nbytes)  # 96
```

**结果**：`96`

**计算方式**：`nbytes = size × itemsize = 12 × 8 = 96` 字节

**实用场景**：估算大数组的内存占用。

```python
# 创建一个大数组
big_arr = np.zeros((10000, 10000))
print(f"占用内存: {big_arr.nbytes / 1024 / 1024:.2f} MB")
```

**结果**：`占用内存: 762.94 MB`

## 常用数据类型

### 整数类型

| 类型    | 说明      | 范围                           | 字节数 |
| ------- | --------- | ------------------------------ | ------ |
| `int8`  | 8 位整数  | -128 ~ 127                     | 1      |
| `int16` | 16 位整数 | -32,768 ~ 32,767               | 2      |
| `int32` | 32 位整数 | -2,147,483,648 ~ 2,147,483,647 | 4      |
| `int64` | 64 位整数 | -9×10¹⁸ ~ 9×10¹⁸               | 8      |

**如何选择？**

- 一般用默认的 `int64`
- 处理大量数据且值范围小时，用 `int32` 或 `int16` 节省内存

### 浮点类型

| 类型      | 说明        | 精度                    | 字节数 |
| --------- | ----------- | ----------------------- | ------ |
| `float16` | 16 位浮点数 | 半精度                  | 2      |
| `float32` | 32 位浮点数 | 单精度（~7位有效数字）  | 4      |
| `float64` | 64 位浮点数 | 双精度（~15位有效数字） | 8      |

**如何选择？**

- 科学计算用 `float64`（默认）
- 深度学习训练常用 `float32` 节省显存
- `float16` 用于极端内存优化场景

### 其他类型

| 类型         | 说明                  |
| ------------ | --------------------- |
| `bool`       | 布尔类型 (True/False) |
| `complex64`  | 复数 (2 个 float32)   |
| `complex128` | 复数 (2 个 float64)   |

## 数据类型转换 (astype)

`astype()` 方法可以将数组转换为其他数据类型。

```python
# 创建浮点数组
arr_float = np.array([1.5, 2.7, 3.2, 4.8])
print(f"原数组: {arr_float}")
print(f"原类型: {arr_float.dtype}")
```

**结果**：

```
原数组: [1.5 2.7 3.2 4.8]
原类型: float64
```

```python
# 转换为整数（截断小数部分）
arr_int = arr_float.astype(np.int32)
print(f"转换后: {arr_int}")
print(f"新类型: {arr_int.dtype}")
```

**结果**：

```
转换后: [1 2 3 4]
新类型: int32
```

**注意**：浮点转整数是**截断**（直接丢弃小数），不是四舍五入！

- 1.5 → 1（不是 2）
- 2.7 → 2（不是 3）

```python
# 如果需要四舍五入
arr_rounded = np.round(arr_float).astype(np.int32)
print(arr_rounded)  # [2 3 3 5]
```

```python
# 转换为字符串
arr_str = arr_float.astype(str)
print(arr_str)  # ['1.5' '2.7' '3.2' '4.8']
```

> **重要**：`astype()` 返回新数组，不会修改原数组！

## 布尔数组

布尔数组是 NumPy 中非常强大的工具，用于条件筛选。

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 通过比较运算创建布尔数组
bool_arr = arr > 5
print(bool_arr)
```

**结果**：`[False False False False False  True  True  True  True  True]`

**原理**：每个元素与 5 比较，大于 5 的位置为 True，否则为 False。

```python
# 布尔数组的类型
print(bool_arr.dtype)  # bool
```

### 布尔索引

布尔数组可以直接用于索引，筛选出 True 对应的元素：

```python
# 筛选大于 5 的元素
print(arr[bool_arr])  # [6, 7, 8, 9, 10]

# 或者直接写
print(arr[arr > 5])   # [6, 7, 8, 9, 10]
```

### 统计 True 的数量

```python
# True 被当作 1，False 被当作 0
print(bool_arr.sum())  # 5
```

**结果**：`5`

**含义**：有 5 个元素大于 5。

```python
# 计算比例
print(bool_arr.mean())  # 0.5
```

**结果**：`0.5`

**含义**：50% 的元素大于 5。

## 查看数据类型信息

```python
# 整数类型信息
print(np.iinfo(np.int32))
```

**结果**：

```
Machine parameters for int32
---------------------------------------------------------------
min = -2147483648
max = 2147483647
---------------------------------------------------------------
```

**用途**：了解某个整数类型能表示的最大最小值。

```python
# 浮点类型信息
print(np.finfo(np.float64))
```

**结果**显示精度、最小正数、最大值等信息。

## 小结

1. **形状相关**：`shape`（形状）、`ndim`（维度数）、`size`（元素总数）
2. **内存相关**：`dtype`（数据类型）、`itemsize`（单元素字节数）、`nbytes`（总字节数）
3. **类型转换**：使用 `astype()` 转换数据类型，返回新数组
4. **布尔数组**：用于条件筛选，`sum()` 统计 True 数量

## 练习
1. 创建一个 100×100 的随机数组，计算它占用多少 KB 内存
2. 将浮点数组 `[1.1, 2.5, 3.9, 4.4]` 转换为整数，对比 `astype(int)` 和 `np.round().astype(int)` 的区别
3. 创建数组 `[1,2,3,...,100]`，统计其中有多少个偶数

# 索引和切片

## 学习目标

- 掌握 NumPy 数组的基本索引方法
- 学会使用切片操作访问数组元素
- 理解布尔索引和花式索引

## 为什么索引很重要？

索引和切片是数据处理的基础操作。你需要用它们来：

- 获取特定位置的数据
- 提取数据的子集（如前 100 条记录）
- 根据条件筛选数据（如找出所有大于阈值的值）
- 修改数组中的部分元素

## 索引方式对比

| 索引类型 | 语法                   | 说明               | 返回结果     |
| -------- | ---------------------- | ------------------ | ------------ |
| 基本索引 | `arr[0]`, `arr[1,2]`   | 访问单个元素       | 标量或数组   |
| 切片索引 | `arr[0:5]`, `arr[::2]` | 访问连续或间隔元素 | 数组（视图） |
| 布尔索引 | `arr[arr > 5]`         | 根据条件筛选元素   | 数组（副本） |
| 花式索引 | `arr[[0,2,4]]`         | 使用整数数组索引   | 数组（副本） |

## 基本索引

### 一维数组索引

```python
arr_1d = np.array([10, 20, 30, 40, 50])

# 正向索引（从 0 开始）
print(arr_1d[0])   # 10 (第一个元素)
print(arr_1d[2])   # 30 (第三个元素)
```

**原理**：Python 索引从 0 开始，所以 `arr[0]` 是第一个元素，`arr[1]` 是第二个。

```python
# 负向索引（从 -1 开始，表示倒数第几个）
print(arr_1d[-1])  # 50 (最后一个元素)
print(arr_1d[-2])  # 40 (倒数第二个元素)
```

**技巧**：`-1` 表示最后一个，`-2` 表示倒数第二个，以此类推。不需要知道数组长度就能访问末尾元素。

### 二维数组索引

```python
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])

# 访问单个元素：arr[行, 列]
print(arr_2d[0, 0])   # 1 (第一行第一列)
print(arr_2d[1, 2])   # 6 (第二行第三列)
print(arr_2d[-1, -1]) # 9 (最后一行最后一列)
```

**理解**：`arr_2d[1, 2]` 中，`1` 是行索引（第二行），`2` 是列索引（第三列）。

```python
# 获取整行
print(arr_2d[0])      # [1, 2, 3] (第一行)
print(arr_2d[1])      # [4, 5, 6] (第二行)

# 获取整列需要用切片
print(arr_2d[:, 0])   # [1, 4, 7] (第一列)
```

## 切片语法

```
arr[start:stop:step]
```

| 参数    | 说明               | 默认值   |
| ------- | ------------------ | -------- |
| `start` | 起始索引（包含）   | 0        |
| `stop`  | 结束索引（不包含） | 数组长度 |
| `step`  | 步长               | 1        |

**记忆口诀**：包头不包尾（包含 start，不包含 stop）

### 一维数组切片

```python
arr = np.arange(10)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**示例 1：指定起止**

```python
print(arr[2:7])   # [2, 3, 4, 5, 6]
```

**解读**：从索引 2 开始，到索引 7 之前结束（不包含 7）。

**示例 2：省略参数**

```python
print(arr[:5])    # [0, 1, 2, 3, 4]  从开头到索引 5
print(arr[5:])    # [5, 6, 7, 8, 9]  从索引 5 到结尾
print(arr[:])     # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  全部元素
```

**示例 3：使用步长**

```python
print(arr[::2])   # [0, 2, 4, 6, 8]  每隔一个取一个（偶数索引）
print(arr[1::2])  # [1, 3, 5, 7, 9]  从索引 1 开始，每隔一个取一个（奇数索引）
```

**示例 4：负步长（反转）**

```python
print(arr[::-1])  # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  数组反转
print(arr[::-2])  # [9, 7, 5, 3, 1]  反向每隔一个取
```

### 二维数组切片

```python
arr = np.arange(20).reshape(4, 5)
print(arr)
```

**结果**：

```
[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]]
```

```python
# 前 2 行
print(arr[:2, :])
```

**结果**：

```
[[0 1 2 3 4]
 [5 6 7 8 9]]
```

```python
# 第 2-4 列（索引 1, 2, 3）
print(arr[:, 1:4])
```

**结果**：

```
[[ 1  2  3]
 [ 6  7  8]
 [11 12 13]
 [16 17 18]]
```

```python
# 子矩阵：第 2-3 行，第 2-3 列
print(arr[1:3, 1:3])
```

**结果**：

```
[[ 6  7]
 [11 12]]
```

```python
# 每隔一行每隔一列
print(arr[::2, ::2])
```

**结果**：

```
[[ 0  2  4]
 [10 12 14]]
```

## 切片是视图（重要！）

```python
arr = np.array([1, 2, 3, 4, 5])
slice_arr = arr[1:4]  # [2, 3, 4]

# 修改切片会影响原数组！
slice_arr[0] = 100
print(arr)  # [1, 100, 3, 4, 5]
```

**原理**：切片返回的是**视图**（view），指向原数组的同一块内存。修改视图会影响原数组。

**如果需要副本**：

```python
slice_copy = arr[1:4].copy()  # 创建副本
slice_copy[0] = 200
print(arr)  # [1, 100, 3, 4, 5]  原数组不受影响
```

## 布尔索引

布尔索引使用条件表达式筛选元素，是数据分析中最常用的技术之一。

```python
arr = np.arange(1, 11)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

### 单条件筛选

```python
# 大于 5 的元素
print(arr[arr > 5])
```

**结果**：`[6 7 8 9 10]`

**工作原理**：

1. `arr > 5` 生成布尔数组：`[False False False False False True True True True True]`
2. 用布尔数组索引，只保留 True 位置的元素

```python
# 偶数元素
print(arr[arr % 2 == 0])
```

**结果**：`[2 4 6 8 10]`

### 多条件筛选

```python
# 3 到 7 之间的元素（使用 & 表示"且"）
print(arr[(arr >= 3) & (arr <= 7)])
```

**结果**：`[3 4 5 6 7]`

```python
# 小于 3 或大于 8 的元素（使用 | 表示"或"）
print(arr[(arr < 3) | (arr > 8)])
```

**结果**：`[1 2 9 10]`

```python
# 不大于 5 的元素（使用 ~ 表示"非"）
print(arr[~(arr > 5)])
```

**结果**：`[1 2 3 4 5]`

> **重要**：多条件组合时，每个条件必须用括号包围！
>
> - 错误：`arr[arr > 3 & arr < 7]`
> - 正确：`arr[(arr > 3) & (arr < 7)]`

## 花式索引

花式索引使用整数数组来指定要获取的元素位置。

```python
arr = np.arange(10, 20)  # [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

# 获取索引 0, 2, 5, 8 位置的元素
indices = [0, 2, 5, 8]
print(arr[indices])
```

**结果**：`[10 12 15 18]`

**应用场景**：当你有一个索引列表，想一次性获取多个不连续位置的元素。

### 二维数组的花式索引

```python
arr_2d = np.arange(12).reshape(3, 4)
print(arr_2d)
```

**结果**：

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
```

```python
# 选择第 0 行和第 2 行
print(arr_2d[[0, 2]])
```

**结果**：

```
[[ 0  1  2  3]
 [ 8  9 10 11]]
```

```python
# 选择特定位置的元素：(0,0), (1,1), (2,2)
rows = [0, 1, 2]
cols = [0, 1, 2]
print(arr_2d[rows, cols])
```

**结果**：`[0 5 10]`（对角线元素）

**理解**：`arr_2d[[0,1,2], [0,1,2]]` 实际上是获取 `arr_2d[0,0]`、`arr_2d[1,1]`、`arr_2d[2,2]`。

## np.where 条件索引

`np.where` 是一个功能强大的条件函数，有两种用法。

### 用法 1：返回满足条件的索引

```python
arr = np.array([1, -2, 3, -4, 5, -6])
indices = np.where(arr > 0)
print(indices)
```

**结果**：`(array([0, 2, 4]),)`

**含义**：索引 0, 2, 4 位置的元素大于 0。

### 用法 2：条件替换（三参数形式）

```python
# np.where(条件, 满足时的值, 不满足时的值)

# 负数替换为 0，正数保留
result = np.where(arr > 0, arr, 0)
print(result)
```

**结果**：`[1 0 3 0 5 0]`

```python
# 正数标记为 1，负数标记为 -1
result = np.where(arr > 0, 1, -1)
print(result)
```

**结果**：`[1 -1 1 -1 1 -1]`

**应用场景**：

- 数据清洗：将异常值替换为特定值
- 特征工程：将连续值转换为分类标签

## 小结

| 索引类型 | 语法示例       | 返回类型  | 是否修改原数组     |
| -------- | -------------- | --------- | ------------------ |
| 基本索引 | `arr[0]`       | 元素/数组 | 是                 |
| 切片     | `arr[1:5]`     | 视图      | 是（通过视图修改） |
| 布尔索引 | `arr[arr>5]`   | 副本      | 否                 |
| 花式索引 | `arr[[1,3,5]]` | 副本      | 否                 |

1. **基本索引**：用于访问单个元素或行/列
2. **切片**：用于获取连续的数据片段，返回视图
3. **布尔索引**：用于条件筛选，最常用
4. **花式索引**：用于获取不连续位置的多个元素
5. **np.where**：条件判断和替换的利器

## 练习
1. 创建数组 `[0,1,2,...,19]`，提取所有偶数
2. 创建 5×5 矩阵，提取中间 3×3 的子矩阵
3. 将数组 `[-3, -1, 0, 2, 5]` 中的负数全部替换为 0

# 数组运算

## 学习目标

- 掌握 NumPy 数组的基本数学运算
- 理解向量化操作的优势
- 学会使用比较运算和逻辑运算

## 为什么学习数组运算？

数据处理和机器学习中，90% 以上的时间都在进行数学运算：

- 数据标准化：减去均值，除以标准差
- 特征计算：求和、均值、方差
- 模型预测：矩阵乘法、激活函数

NumPy 的向量化运算让这些操作既简洁又高效。

## 运算类型

| 类型     | 运算符/函数                         | 说明         |
| -------- | ----------------------------------- | ------------ |
| 算术运算 | `+`, `-`, `*`, `/`, `**`, `//`, `%` | 元素级运算   |
| 比较运算 | `>`, `<`, `>=`, `<=`, `==`, `!=`    | 返回布尔数组 |
| 逻辑运算 | `&`, `\|`, `~`, `np.logical_and()`  | 布尔数组运算 |
| 统计运算 | `sum()`, `mean()`, `std()`, `var()` | 聚合运算     |

## 向量化的优势

### 传统 Python 循环方式（慢）

```python
a = [1, 2, 3, 4, 5]
b = [5, 4, 3, 2, 1]
result = []
for i in range(len(a)):
    result.append(a[i] + b[i])
print(result)
```

**结果**：`[6, 6, 6, 6, 6]`

### NumPy 向量化方式（快）

```python
a = np.array([1, 2, 3, 4, 5])
b = np.array([5, 4, 3, 2, 1])
result = a + b
print(result)
```

**结果**：`[6 6 6 6 6]`

**性能对比**：向量化操作比 Python 循环快 **10-100 倍**！

**原理**：

- Python 循环：每次迭代都有解释器开销、类型检查
- NumPy 向量化：底层用 C 语言批量处理，没有循环开销

## 算术运算

### 数组与数组运算

```python
a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])
```

**加减乘除**：

```python
print(a + b)   # [6  8 10 12]  每个位置相加
print(a - b)   # [-4 -4 -4 -4]  每个位置相减
print(a * b)   # [5 12 21 32]  每个位置相乘
print(a / b)   # [0.2  0.33 0.43 0.5]  每个位置相除
```

**原理**：这是"元素级运算"，也叫"逐元素运算"（element-wise），对应位置的元素进行计算。

### 数组与标量运算

```python
a = np.array([1, 2, 3, 4])

print(a + 10)   # [11 12 13 14]  每个元素加 10
print(a * 2)    # [2 4 6 8]      每个元素乘 2
print(a ** 2)   # [1 4 9 16]     每个元素平方
```

**原理**：标量会自动"广播"到数组的每个元素。

### 更多运算符

```python
a = np.array([1, 2, 3, 4, 5])

# 幂运算
print(a ** 2)      # [1 4 9 16 25]  平方
print(a ** 0.5)    # [1.  1.41 1.73 2.  2.24]  平方根

# 整除
print(a // 2)      # [0 1 1 2 2]  整数除法，向下取整

# 取余
print(a % 2)       # [1 0 1 0 1]  余数，可用于判断奇偶
```

**应用场景**：

- `% 2 == 0`：判断偶数
- `** 0.5`：计算平方根（比 `np.sqrt()` 更直观）

## 比较运算

比较运算返回布尔数组，常用于条件筛选。

```python
a = np.array([1, 2, 3, 4])
b = np.array([4, 3, 2, 1])

# 元素级比较
print(a > b)    # [False False  True  True]
print(a < b)    # [ True  True False False]
print(a == b)   # [False False False False]
print(a >= 2)   # [False  True  True  True]
```

**结果解读**：

- `a > b` 比较对应位置：1>4? False, 2>3? False, 3>2? True, 4>1? True

### 数组整体比较

```python
# 检查两个数组是否完全相同
np.array_equal(a, b)  # False

# 检查是否有任意元素相同
np.any(a == b)        # False

# 检查是否所有元素都满足条件
np.all(a != b)        # True
```

**使用场景**：

- `np.array_equal()`：验证两个数组完全一致
- `np.any()`：检查是否存在满足条件的元素
- `np.all()`：检查是否全部满足条件

## 统计运算

统计运算是数据分析的核心功能。

| 函数                   | 说明            | 数学符号 |
| ---------------------- | --------------- | -------- |
| `sum()`                | 求和            | Σ        |
| `mean()`               | 均值            | μ        |
| `std()`                | 标准差          | σ        |
| `var()`                | 方差            | σ²       |
| `min()`, `max()`       | 最小/最大值     | min, max |
| `argmin()`, `argmax()` | 最小/最大值索引 | —        |
| `cumsum()`             | 累积和          | —        |
| `cumprod()`            | 累积积          | —        |

### 基本统计

```python
arr = np.array([1, 2, 3, 4, 5])

print(arr.sum())     # 15  = 1+2+3+4+5
print(arr.mean())    # 3.0 = 15/5
print(arr.std())     # 1.41 标准差
print(arr.var())     # 2.0 方差 = std²
print(arr.min())     # 1 最小值
print(arr.max())     # 5 最大值
```

**标准差和方差的含义**：

- 方差：每个数与均值差的平方的平均值，衡量数据的"分散程度"
- 标准差：方差的平方根，与原数据同单位

### 索引统计

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])

print(arr.argmin())  # 1  最小值的索引（值为1的位置）
print(arr.argmax())  # 5  最大值的索引（值为9的位置）
```

**应用场景**：找到最高分学生的位置、找到最低价格的商品索引。

### 累积运算

```python
arr = np.array([1, 2, 3, 4, 5])

print(arr.cumsum())   # [1 3 6 10 15]
print(arr.cumprod())  # [1 2 6 24 120]
```

**cumsum 计算过程**：

- 第1个：1
- 第2个：1+2=3
- 第3个：1+2+3=6
- 第4个：1+2+3+4=10
- 第5个：1+2+3+4+5=15

**应用场景**：计算累计销售额、累计概率等。

## 沿轴运算 (axis)

对于多维数组，可以指定沿哪个轴进行运算。

```python
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])
```

### axis=None：所有元素

```python
print(arr.sum())  # 45
```

**含义**：对所有 9 个元素求和。

### axis=0：沿行方向（按列计算）

```python
print(arr.sum(axis=0))   # [12 15 18]
print(arr.mean(axis=0))  # [4. 5. 6.]
```

**计算过程**：

```
列0: 1+4+7=12
列1: 2+5+8=15
列2: 3+6+9=18
```

**记忆技巧**：`axis=0` 表示"压缩第0维（行）"，结果按列排列。

### axis=1：沿列方向（按行计算）

```python
print(arr.sum(axis=1))   # [6 15 24]
print(arr.mean(axis=1))  # [2. 5. 8.]
```

**计算过程**：

```
行0: 1+2+3=6
行1: 4+5+6=15
行2: 7+8+9=24
```

**记忆技巧**：`axis=1` 表示"压缩第1维（列）"，结果按行排列。

## 数学函数

### 三角函数

```python
angles = np.array([0, np.pi/6, np.pi/4, np.pi/3, np.pi/2])
# 对应角度：0°, 30°, 45°, 60°, 90°

print(np.sin(angles).round(3))  # [0.  0.5  0.707 0.866 1.]
print(np.cos(angles).round(3))  # [1.  0.866 0.707 0.5  0.]
```

**注意**：NumPy 使用弧度制，不是角度制。`np.pi` ≈ 3.14159。

### 指数和对数

```python
arr = np.array([1, 2, 3, 4, 5])

print(np.exp(arr))     # [2.72 7.39 20.09 54.60 148.41]  e^x
print(np.log(arr))     # [0. 0.69 1.10 1.39 1.61]  自然对数 ln(x)
print(np.log10(arr))   # [0. 0.30 0.48 0.60 0.70]  以10为底
print(np.log2(arr))    # [0. 1. 1.58 2. 2.32]  以2为底
```

**应用场景**：

- `exp`：机器学习中的 softmax 函数
- `log`：信息熵计算、对数变换

### 取整函数

```python
arr = np.array([1.2, 2.5, 3.7, -1.2, -2.5])

print(np.floor(arr))   # [1. 2. 3. -2. -3.]  向下取整（往小的方向）
print(np.ceil(arr))    # [2. 3. 4. -1. -2.]  向上取整（往大的方向）
print(np.round(arr))   # [1. 2. 4. -1. -2.]  四舍五入
print(np.abs(arr))     # [1.2 2.5 3.7 1.2 2.5]  绝对值
```

**注意**：`np.round(2.5)` 结果是 2（四舍五入到偶数），这是银行家舍入法。

## 逻辑运算

用于组合多个布尔数组。

```python
a = np.array([True, True, False, False])
b = np.array([True, False, True, False])

print(np.logical_and(a, b))  # [True False False False]  与
print(np.logical_or(a, b))   # [True True True False]   或
print(np.logical_not(a))     # [False False True True]  非
print(np.logical_xor(a, b))  # [False True True False]  异或
```

**真值表**：
| a | b | and | or | xor |
| ----- | ----- | ----- | ----- | ----- |
| True | True | True | True | False |
| True | False | False | True | True |
| False | True | False | True | True |
| False | False | False | False | False |

## 小结

1. **向量化运算**：比循环快 10-100 倍，是 NumPy 的核心优势
2. **元素级运算**：`+`, `-`, `*`, `/` 对应位置计算
3. **统计函数**：`sum`, `mean`, `std`, `min`, `max` 是数据分析的基础
4. **axis 参数**：控制沿哪个维度计算，`axis=0` 按列，`axis=1` 按行
5. **数学函数**：`sin`, `cos`, `exp`, `log` 等都支持数组输入

## 练习
1. 创建数组 `[1,2,3,4,5]`，计算所有元素的平方和
2. 创建 3×4 矩阵，分别计算每行的均值和每列的均值
3. 创建 100 个 0-100 的随机整数，统计大于 50 的有多少个

# 线性代数

## 学习目标

- 掌握 NumPy 中的线性代数运算
- 理解矩阵运算的概念
- 学会使用 NumPy 的线性代数函数

## 为什么学习线性代数？

线性代数是机器学习的数学基础：

- **线性回归**：求解最小二乘问题
- **PCA 降维**：特征值分解
- **神经网络**：矩阵乘法是核心运算
- **推荐系统**：矩阵分解

NumPy 的 `np.linalg` 模块提供了完整的线性代数支持。

## 重要函数 (np.linalg 模块)

| 函数                    | 说明                          |
| ----------------------- | ----------------------------- |
| `np.dot(a, b)`          | 矩阵乘法（或向量点积）        |
| `a @ b`                 | 矩阵乘法运算符（Python 3.5+） |
| `np.linalg.inv(a)`      | 矩阵求逆                      |
| `np.linalg.det(a)`      | 计算行列式                    |
| `np.linalg.eig(a)`      | 计算特征值和特征向量          |
| `np.linalg.solve(a, b)` | 解线性方程组 Ax = b           |
| `np.linalg.norm(a)`     | 计算范数                      |

## 矩阵乘法 vs 元素乘法

这是最容易混淆的概念，必须区分清楚！

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
```

### 元素乘法（对应位置相乘）

```python
print(A * B)
```

**结果**：

```
[[ 5 12]
 [21 32]]
```

**计算过程**：

```
1×5=5   2×6=12
3×7=21  4×8=32
```

### 矩阵乘法（线性代数乘法）

```python
print(A @ B)  # 推荐写法
# 或 print(np.dot(A, B))
```

**结果**：

```
[[19 22]
 [43 50]]
```

**计算过程**（行×列求和）：

```
(1×5+2×7)=19  (1×6+2×8)=22
(3×5+4×7)=43  (3×6+4×8)=50
```

**记忆方法**：

- `*` 星号：元素对元素
- `@` at符：矩阵乘矩阵

**矩阵乘法规则**：`(m×n) @ (n×p) = (m×p)`，第一个矩阵的列数必须等于第二个矩阵的行数。

## 向量点积

点积（内积）是两个向量对应元素相乘后求和。

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = np.dot(a, b)
print(result)  # 32
```

**计算过程**：1×4 + 2×5 + 3×6 = 4 + 10 + 18 = 32

**几何意义**：

- 点积 > 0：两向量夹角 < 90°
- 点积 = 0：两向量垂直
- 点积 < 0：两向量夹角 > 90°

**应用场景**：

- 计算向量相似度（余弦相似度的分子）
- 神经网络中的加权求和

## 矩阵转置

转置就是把行变成列，列变成行。

```python
A = np.array([[1, 2, 3],
              [4, 5, 6]])  # 2×3 矩阵

print(A.T)
```

**结果**：

```
[[1 4]
 [2 5]
 [3 6]]
```

**形状变化**：2×3 → 3×2

**转置的性质**：

- `(A.T).T = A`：转置两次等于原矩阵
- `(A @ B).T = B.T @ A.T`：乘积的转置 = 转置的逆序乘积

## 行列式和逆矩阵

### 行列式

行列式是方阵的一个标量值，表示矩阵对空间的"缩放因子"。

```python
A = np.array([[4, 7], [2, 6]])

det = np.linalg.det(A)
print(det)  # 10.0
```

**2×2 矩阵行列式公式**：`|A| = ad - bc`

```
|4 7|
|2 6| = 4×6 - 7×2 = 24 - 14 = 10
```

**行列式的含义**：

- det = 0：矩阵不可逆（奇异矩阵）
- |det| > 1：矩阵放大空间
- |det| < 1：矩阵缩小空间

### 逆矩阵

逆矩阵满足：A × A⁻¹ = I（单位矩阵）

```python
A = np.array([[4, 7], [2, 6]])

A_inv = np.linalg.inv(A)
print(A_inv)
```

**结果**：

```
[[ 0.6 -0.7]
 [-0.2  0.4]]
```

**验证**：

```python
print(A @ A_inv)
```

**结果**：

```
[[1. 0.]
 [0. 1.]]
```

结果接近单位矩阵（可能有微小浮点误差）。

> **注意**：只有方阵（行数=列数）且行列式不为 0 才能求逆矩阵。

## 特征值和特征向量

**什么是特征值和特征向量？**

如果矩阵 A 作用于向量 v 后，结果仍然是 v 的倍数，即 Av = λv，那么：

- v 是 A 的**特征向量**
- λ 是对应的**特征值**

```python
A = np.array([[4, 2], [1, 3]])

eigenvalues, eigenvectors = np.linalg.eig(A)

print("特征值:", eigenvalues)
print("特征向量:\n", eigenvectors)
```

**结果**：

```
特征值: [5. 2.]
特征向量:
 [[ 0.894 -0.707]
  [ 0.447  0.707]]
```

**验证 Av = λv**：

```python
v = eigenvectors[:, 0]  # 第一个特征向量
lam = eigenvalues[0]    # 对应的特征值 5

print("A @ v =", A @ v)
print("λ * v =", lam * v)
```

两个结果应该相等。

**应用场景**：

- PCA 降维：找最大特征值对应的特征向量
- 图像压缩、推荐系统

## 解线性方程组

求解 **Ax = b** 类型的方程组。

**例题**：解方程组

```
2x + y = 5
x + 3y = 7
```

**NumPy 解法**：

```python
A = np.array([[2, 1], [1, 3]])
b = np.array([5, 7])

x = np.linalg.solve(A, b)
print(x)
```

**结果**：`[1.6 1.8]`

**含义**：x = 1.6, y = 1.8

**验证**：

```python
print(A @ x)  # 应该等于 b = [5, 7]
```

**为什么用 solve 而不用 inv？**

```python
# 两种方法等价，但 solve 更快更稳定
x = np.linalg.solve(A, b)  # 推荐
x = np.linalg.inv(A) @ b   # 不推荐
```

## 向量和矩阵范数

范数是衡量向量或矩阵"大小"的方式。

### L1 范数（曼哈顿距离）

```python
v = np.array([3, 4])
print(np.linalg.norm(v, ord=1))  # 7
```

**计算**：|3| + |4| = 7

**几何意义**：城市街区距离（只能走横竖）。

### L2 范数（欧几里得距离）

```python
print(np.linalg.norm(v, ord=2))  # 5
# 或 np.linalg.norm(v)  默认是 L2
```

**计算**：√(3² + 4²) = √25 = 5

**几何意义**：直线距离。

### 无穷范数

```python
print(np.linalg.norm(v, ord=np.inf))  # 4
```

**计算**：max(|3|, |4|) = 4

**含义**：最大的分量。

### 矩阵 Frobenius 范数

```python
A = np.array([[1, 2], [3, 4]])
print(np.linalg.norm(A))  # 5.477
```

**计算**：√(1² + 2² + 3² + 4²) = √30 ≈ 5.477

## 其他线性代数函数

| 函数                       | 说明          | 应用场景           |
| -------------------------- | ------------- | ------------------ |
| `np.linalg.matrix_rank(A)` | 矩阵的秩      | 判断方程组解的情况 |
| `np.linalg.svd(A)`         | 奇异值分解    | 降维、推荐系统     |
| `np.linalg.qr(A)`          | QR 分解       | 数值稳定的求解     |
| `np.linalg.cholesky(A)`    | Cholesky 分解 | 正定矩阵分解       |

## 浮点精度问题

矩阵运算中经常遇到浮点精度问题，结果可能有微小误差。

```python
A = np.array([[4, 7], [2, 6]])
result = A @ np.linalg.inv(A)

# 不要这样比较！
print(result == np.eye(2))  # 可能有 False

# 应该这样比较
print(np.allclose(result, np.eye(2)))  # True
```

`np.allclose()` 允许微小误差（默认容差 1e-8）。

## 小结

| 操作     | 函数/运算符           | 说明               |
| -------- | --------------------- | ------------------ |
| 元素乘法 | `A * B`               | 对应位置相乘       |
| 矩阵乘法 | `A @ B` 或 `np.dot()` | 线性代数乘法       |
| 转置     | `A.T`                 | 行列互换           |
| 逆矩阵   | `np.linalg.inv(A)`    | A × A⁻¹ = I        |
| 行列式   | `np.linalg.det(A)`    | 标量，判断是否可逆 |
| 解方程   | `np.linalg.solve()`   | 解 Ax = b          |

## 练习
1. 计算向量 `[1, 2, 3]` 和 `[4, 5, 6]` 的点积
2. 解方程组：3x + 2y = 12, x + 4y = 10
3. 验证 2×2 矩阵 `[[1,2],[3,4]]` 与其逆矩阵相乘等于单位矩阵

# 数组变形

## 学习目标

- 掌握 NumPy 数组的变形方法
- 学会改变数组的形状和维度
- 理解数组转置和轴变换

## 为什么需要数组变形？

在数据处理中，经常需要改变数据的形状：

- 把一维数据变成二维表格
- 神经网络输入需要特定的维度格式
- 矩阵运算前需要调整形状
- 把多维数据展平用于可视化

## 核心方法

| 方法              | 说明             | 返回类型         |
| ----------------- | ---------------- | ---------------- |
| `reshape(shape)`  | 改变数组形状     | 视图（如果可能） |
| `flatten()`       | 展平为一维       | 副本             |
| `ravel()`         | 展平为一维       | 视图（如果可能） |
| `T`               | 转置             | 视图             |
| `transpose(axes)` | 按指定轴顺序转置 | 视图             |

## 视图 vs 副本

这是 NumPy 中非常重要的概念！

| 类型            | 说明             | 修改是否影响原数组 |
| --------------- | ---------------- | ------------------ |
| **视图 (View)** | 与原数组共享数据 | 是                 |
| **副本 (Copy)** | 独立的数据拷贝   | 否                 |

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# flatten() 返回副本
flat = arr.flatten()
flat[0] = 999
print(arr[0, 0])  # 1 (原数组不变)

# ravel() 返回视图
rav = arr.ravel()
rav[0] = 999
print(arr[0, 0])  # 999 (原数组被修改！)
```

**选择建议**：

- 需要独立副本：用 `flatten()`
- 只需要临时访问：用 `ravel()`（更快、更省内存）

## reshape 变形

`reshape` 是最常用的变形方法，可以把数组转换成任意兼容的形状。

```python
arr = np.arange(1, 13)  # [1, 2, 3, ..., 12]
print(arr.shape)  # (12,)
```

### 变形为二维

```python
# 变形为 3 行 4 列
result = arr.reshape(3, 4)
print(result)
```

**结果**：

```
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]
```

**原理**：元素按行填充（C 顺序），先填满第一行，再填第二行...

```python
# 变形为 4 行 3 列
print(arr.reshape(4, 3))
```

**结果**：

```
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]]
```

### 使用 -1 自动计算

当你知道一个维度，让 NumPy 自动计算另一个维度。

```python
# 知道要 2 行，自动计算列数
print(arr.reshape(2, -1))   # (2, 6)

# 知道要 6 列，自动计算行数
print(arr.reshape(-1, 6))   # (2, 6)

# 知道要 3 行，自动计算列数
print(arr.reshape(3, -1))   # (3, 4)
```

**注意**：只能有一个 `-1`，不能 `reshape(-1, -1)`。

### 变形限制

元素总数必须保持不变！

```python
arr = np.arange(12)  # 12 个元素

arr.reshape(3, 4)    # ✓ 3×4=12
arr.reshape(2, 6)    # ✓ 2×6=12
arr.reshape(3, 5)    # ✗ 错误！3×5=15≠12
```

## flatten 和 ravel 展平

把多维数组变成一维。

```python
arr = np.array([[1, 2, 3],
                [4, 5, 6]])
```

### 默认按行展平（C 顺序）

```python
print(arr.flatten())   # [1 2 3 4 5 6]
print(arr.ravel())     # [1 2 3 4 5 6]
```

**顺序**：先遍历第一行，再遍历第二行。

### 按列展平（Fortran 顺序）

```python
print(arr.flatten('F'))  # [1 4 2 5 3 6]
print(arr.ravel('F'))    # [1 4 2 5 3 6]
```

**顺序**：先遍历第一列，再遍历第二列。

## 转置

### 二维数组转置

转置就是把行变成列、列变成行。

```python
arr = np.array([[1, 2, 3],
                [4, 5, 6]])  # (2, 3)

print(arr.T)
```

**结果**：

```
[[1 4]
 [2 5]
 [3 6]]
```

**形状变化**：(2, 3) → (3, 2)

**应用场景**：

- 矩阵运算前调整形状
- 行列数据互换

### 一维数组转置

```python
arr_1d = np.array([1, 2, 3])
print(arr_1d.T)  # [1 2 3] 形状不变！
```

**注意**：一维数组转置后形状不变！如果需要变成列向量：

```python
arr_1d[:, np.newaxis]  # 变成 (3, 1)
arr_1d.reshape(-1, 1)  # 变成 (3, 1)
```

### 三维数组转置

```python
arr_3d = np.arange(24).reshape(2, 3, 4)  # (2, 3, 4)

# 默认转置：完全反转维度顺序
print(arr_3d.T.shape)  # (4, 3, 2)

# 指定轴顺序
print(np.transpose(arr_3d, axes=(1, 0, 2)).shape)  # (3, 2, 4)
```

**原理**：`axes=(1, 0, 2)` 表示新数组的第 0 维来自原数组的第 1 维，以此类推。

## squeeze 和 expand_dims

### squeeze：移除长度为 1 的维度

当数组有多余的维度时，用 `squeeze` 压缩。

```python
arr = np.array([[[1, 2, 3]]])  # (1, 1, 3)
print(np.squeeze(arr).shape)   # (3,)
```

**应用场景**：

- 模型输出有多余的批次维度
- 从 (1, 10) 变成 (10,)

```python
arr = np.zeros((1, 5, 1, 3))
print(np.squeeze(arr).shape)   # (5, 3) 所有 1 都被移除
```

### expand_dims：增加维度

为数组增加一个新的维度（长度为 1）。

```python
arr = np.array([1, 2, 3])  # (3,)

# 在第 0 维增加（变成行向量）
print(np.expand_dims(arr, axis=0).shape)  # (1, 3)

# 在第 1 维增加（变成列向量）
print(np.expand_dims(arr, axis=1).shape)  # (3, 1)
```

**应用场景**：

- 神经网络输入需要批次维度 (batch_size, ...)
- 为广播做准备

## np.newaxis 增加维度

`np.newaxis` 是另一种增加维度的方式，更简洁。

```python
arr = np.array([1, 2, 3, 4, 5])  # (5,)

# 增加行维度
print(arr[np.newaxis, :].shape)  # (1, 5)
# 等价于 arr.reshape(1, -1)

# 增加列维度
print(arr[:, np.newaxis].shape)  # (5, 1)
# 等价于 arr.reshape(-1, 1)
```

**记忆方法**：`np.newaxis` 放在哪个位置，就在那里增加一个维度。

## resize 调整大小

`resize` 可以改变数组的总大小（元素数量可以变化）。

```python
arr = np.array([1, 2, 3, 4])

# 目标更大时，重复元素
result = np.resize(arr, (2, 4))
print(result)
```

**结果**：

```
[[1 2 3 4]
 [1 2 3 4]]
```

```python
# 不整除时循环填充
result = np.resize(arr, (3, 3))
print(result)
```

**结果**：

```
[[1 2 3]
 [4 1 2]
 [3 4 1]]
```

**与 reshape 的区别**：

- `reshape`：元素数量必须相同
- `resize`：元素数量可以变化

## 常用场景总结

| 场景         | 方法                                       |
| ------------ | ------------------------------------------ |
| 一维变二维   | `reshape(m, n)` 或 `reshape(m, -1)`        |
| 二维变一维   | `flatten()` 或 `ravel()`                   |
| 行列转换     | `.T` 或 `transpose()`                      |
| 添加批次维度 | `expand_dims(axis=0)` 或 `arr[np.newaxis]` |
| 移除多余维度 | `squeeze()`                                |
| 一维变列向量 | `arr[:, np.newaxis]` 或 `reshape(-1, 1)`   |

## 小结

1. **reshape**：最常用，改变形状但元素总数不变
2. **flatten/ravel**：多维变一维，flatten 返回副本，ravel 返回视图
3. **转置 T**：行列互换
4. **squeeze/expand_dims**：移除或增加维度
5. **-1 的妙用**：让 NumPy 自动计算某一维的大小

## 练习
1. 把 `np.arange(24)` 变形为 (4, 6) 的矩阵
2. 把一维数组 `[1,2,3,4,5]` 变成列向量 (5, 1)
3. 创建形状 (1, 3, 1, 4) 的数组，用 squeeze 移除长度为 1 的维度

# 广播机制

## 学习目标

- 理解 NumPy 的广播机制
- 掌握广播的规则和原理
- 学会利用广播进行高效运算

## 什么是广播？

**广播（Broadcasting）** 是 NumPy 中一个强大的机制，允许不同形状的数组进行算术运算。NumPy 会自动"扩展"较小的数组，使其与较大数组形状兼容。

**通俗理解**：当两个形状不同的数组运算时，NumPy 会"聪明地"把小数组复制多份来匹配大数组。

```python
# 没有广播，这样做会报错
[1, 2, 3] + 10  # Python 列表不支持

# 有了广播，这样做就可以
np.array([1, 2, 3]) + 10  # [11, 12, 13]
```

## 广播规则

NumPy 按以下规则判断两个数组是否可以广播：

1. **从后向前**比较每个维度的大小
2. 维度大小**相同**或其中一个为 **1** 时可以广播
3. **缺失的维度**视为 1

### 广播规则图解

```
比较方向: ← ← ←
数组 A: (  3, 4)
数组 B: (     4)  ← 缺失的维度视为 1，即 (1, 4)
结果:   (  3, 4)  ✓ 可以广播
```

### 广播示例

```
数组 A: (3, 4)    数组 B: (4,)     → 结果: (3, 4)  ✓
数组 A: (3, 4)    数组 B: (3, 1)   → 结果: (3, 4)  ✓
数组 A: (3, 1)    数组 B: (1, 4)   → 结果: (3, 4)  ✓
数组 A: (3, 4)    数组 B: (3,)     → 错误！无法广播 ✗
```

**最后一个为什么失败？**

```
数组 A: (3, 4)  → 最后一维是 4
数组 B: (3,)    → 最后一维是 3
4 ≠ 3 且都不是 1，无法广播！
```

## 标量与数组广播

最简单的广播：标量与数组运算。

```python
arr = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])

# 标量广播到所有元素
print(arr + 10)
```

**结果**：

```
[[11 12 13]
 [14 15 16]
 [17 18 19]]
```

**过程可视化**：

```
原数组:          标量 10 广播后:      结果:
[[1 2 3]         [[10 10 10]       [[11 12 13]
 [4 5 6]    +     [10 10 10]   =    [14 15 16]
 [7 8 9]]         [10 10 10]]       [17 18 19]]
```

```python
print(arr * 2)
```

**结果**：

```
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]
```

## 一维与二维数组广播

```python
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])  # (3, 3)
arr_1d = np.array([10, 20, 30])  # (3,)

result = arr_2d + arr_1d
print(result)
```

**结果**：

```
[[11 22 33]
 [14 25 36]
 [17 28 39]]
```

**广播过程**：

```
arr_2d (3, 3):       arr_1d (3,) → (1, 3) → (3, 3):
[[1 2 3]             [[10 20 30]
 [4 5 6]              [10 20 30]    (复制 3 行)
 [7 8 9]]             [10 20 30]]
```

**计算**：每行都加上 `[10, 20, 30]`。

## 列向量广播

如果想让每列加上不同的值，需要把一维数组变成列向量。

```python
arr_2d = np.array([[1, 2, 3],
                   [4, 5, 6],
                   [7, 8, 9]])  # (3, 3)

# 创建列向量 (3, 1)
col = np.array([[100], [200], [300]])

result = arr_2d + col
print(result)
```

**结果**：

```
[[101 102 103]
 [204 205 206]
 [307 308 309]]
```

**广播过程**：

```
arr_2d (3, 3):       col (3, 1) → (3, 3):
[[1 2 3]             [[100 100 100]
 [4 5 6]              [200 200 200]    (每行复制 3 列)
 [7 8 9]]             [300 300 300]]
```

**计算**：第一行加 100，第二行加 200，第三行加 300。

## 广播可视化

```
行向量广播:
数组 A (3, 3):         一维数组 B (3,):
[[1, 2, 3],            [10, 20, 30]
 [4, 5, 6],                ↓ 广播为 (3, 3)
 [7, 8, 9]]            [[10, 20, 30],
                        [10, 20, 30],
                        [10, 20, 30]]

列向量广播:
数组 A (3, 3):         列向量 B (3, 1):
[[1, 2, 3],            [[100],      → 广播为 (3, 3):
 [4, 5, 6],             [200],      [[100, 100, 100],
 [7, 8, 9]]             [300]]       [200, 200, 200],
                                     [300, 300, 300]]
```

## 利用广播实现外积

外积：两个向量生成一个矩阵。

```python
a = np.array([1, 2, 3])        # (3,)
b = np.array([10, 20, 30, 40]) # (4,)

# 方法 1: 利用广播
# a 变成 (3, 1)，b 是 (4,) → (1, 4)
# (3, 1) * (1, 4) → (3, 4)
outer = a[:, np.newaxis] * b
print(outer)
```

**结果**：

```
[[ 10  20  30  40]
 [ 20  40  60  80]
 [ 30  60  90 120]]
```

**过程**：

```
a (3, 1):      b (1, 4):              结果 (3, 4):
[[1]           [[10, 20, 30, 40]]     [[1×10, 1×20, 1×30, 1×40]
 [2]      ×     (广播后每行相同)  →    [2×10, 2×20, 2×30, 2×40]
 [3]]                                  [3×10, 3×20, 3×30, 3×40]]
```

```python
# 方法 2: 使用 np.outer
result = np.outer(a, b)  # 结果相同
```

## 实际应用：数据标准化

标准化是机器学习中最常用的预处理步骤，广播让它变得非常简洁。

```python
# 原始数据 (5 个样本, 3 个特征)
np.random.seed(42)
data = np.random.randint(0, 100, size=(5, 3))
print("原始数据:\n", data)
```

**结果**：

```
原始数据:
 [[51 92 14]
  [71 60 20]
  [82 86 74]
  [74 87 99]
  [23  2 21]]
```

```python
# 计算每列的均值和标准差
mean = data.mean(axis=0)  # (3,)
std = data.std(axis=0)    # (3,)

print("均值:", mean)
print("标准差:", std)
```

**结果**：

```
均值: [60.2 65.4 45.6]
标准差: [20.95 32.71 33.46]
```

```python
# 标准化（利用广播）
# data 是 (5, 3)，mean 和 std 都是 (3,)
# 广播后，每列减去该列的均值，除以该列的标准差
normalized = (data - mean) / std

print("标准化后:\n", normalized.round(2))
```

**结果**：

```
标准化后:
 [[-0.44  0.81 -0.94]
  [ 0.52 -0.16 -0.77]
  [ 1.04  0.63  0.85]
  [ 0.66  0.66  1.6 ]
  [-1.78 -1.94 -0.74]]
```

**验证**：

```python
print("标准化后均值:", normalized.mean(axis=0).round(10))  # 接近 [0, 0, 0]
print("标准化后标准差:", normalized.std(axis=0).round(2))  # 接近 [1, 1, 1]
```

## 广播的优势

1. **代码简洁**：不需要手动循环或复制数组
2. **运算高效**：NumPy 内部优化，不会真的复制数据
3. **内存节省**：小数组不会真的扩展成大数组
4. **表达直观**：数学表达式直接映射为代码

**对比**：

```python
# 不用广播（慢，代码冗长）
result = np.zeros((3, 4))
for i in range(3):
    for j in range(4):
        result[i, j] = arr[i, j] + row[j]

# 用广播（快，代码简洁）
result = arr + row
```

## 常见错误

```python
A = np.ones((3, 4))
B = np.ones((3,))    # 形状 (3,) 而非 (4,)

A + B  # 错误！ValueError
```

**错误原因**：

```
A: (3, 4)  → 最后一维是 4
B: (3,)    → 最后一维是 3
4 ≠ 3 且都不是 1，无法广播！
```

**解决方法**：

```python
# 把 B 变成 (3, 1)，然后可以广播
A + B[:, np.newaxis]  # ✓
```

## 广播兼容性速查

| 形状 A    | 形状 B    | 结果形状  | 是否兼容 |
| --------- | --------- | --------- | -------- |
| (3,)      | (3,)      | (3,)      | ✓        |
| (3, 4)    | (4,)      | (3, 4)    | ✓        |
| (3, 4)    | (3, 1)    | (3, 4)    | ✓        |
| (3, 1)    | (1, 4)    | (3, 4)    | ✓        |
| (3, 4)    | (3,)      | 错误      | ✗        |
| (2, 3, 4) | (3, 4)    | (2, 3, 4) | ✓        |
| (2, 3, 4) | (2, 1, 4) | (2, 3, 4) | ✓        |

## 小结

1. **广播本质**：让不同形状的数组可以进行运算
2. **广播规则**：从后向前比较，相同或为 1 可广播
3. **行向量广播**：(3,) 对 (3, 4) 会按行复制
4. **列向量广播**：(3, 1) 对 (3, 4) 会按列复制
5. **实际应用**：数据标准化、批量计算

## 练习
1. 创建 (4, 3) 矩阵，给每行加上 `[1, 2, 3]`
2. 创建 (4, 3) 矩阵，给每列加上 `[10, 20, 30, 40]`（需要先变成列向量）
3. 判断以下哪些可以广播：(5, 3) 和 (3,)? (5, 3) 和 (5,)? (5, 1, 3) 和 (4, 1)?

# 连接与分割

## 学习目标

- 掌握 NumPy 数组的连接方法
- 学会分割数组
- 理解不同轴的连接和分割

## 为什么需要连接和分割？

在数据处理中，经常需要：

- 合并多个数据集（如训练集和验证集合并）
- 拼接特征列（如把不同来源的特征合并）
- 分割数据集（如划分训练集、验证集、测试集）
- 批量处理大型数组

## 连接函数

| 函数               | 说明                  | 常用场景     |
| ------------------ | --------------------- | ------------ |
| `np.concatenate()` | 沿指定轴连接          | 通用连接     |
| `np.vstack()`      | 垂直堆叠（沿 axis=0） | 合并表格行   |
| `np.hstack()`      | 水平堆叠（沿 axis=1） | 合并表格列   |
| `np.stack()`       | 沿新轴堆叠            | 创建批次维度 |
| `np.dstack()`      | 沿深度方向堆叠        | 合并通道     |

## 分割函数

| 函数               | 说明           | 常用场景         |
| ------------------ | -------------- | ---------------- |
| `np.split()`       | 沿指定轴分割   | 通用分割         |
| `np.vsplit()`      | 垂直分割       | 分割表格行       |
| `np.hsplit()`      | 水平分割       | 分割表格列       |
| `np.array_split()` | 允许不均匀分割 | 数据不能整除时用 |

## 连接 vs 堆叠

| 对比     | concatenate/vstack/hstack | stack/dstack         |
| -------- | ------------------------- | -------------------- |
| 维度变化 | 不增加维度                | 增加一个维度         |
| 形状要求 | 除连接轴外维度相同        | 所有数组形状完全相同 |

**形象理解**：

- **连接**：把两张纸并排放在一起，还是一张（更大的）纸
- **堆叠**：把两张纸叠在一起，变成一叠纸

## concatenate 连接

`concatenate` 是最通用的连接函数，沿指定轴拼接数组。

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

print("A:\n", A)
print("B:\n", B)
```

**结果**：

```
A:
 [[1 2]
  [3 4]]
B:
 [[5 6]
  [7 8]]
```

### 沿 axis=0 连接（垂直拼接）

```python
result = np.concatenate([A, B], axis=0)
print(result)
print("形状:", result.shape)
```

**结果**：

```
[[1 2]
 [3 4]
 [5 6]
 [7 8]]
形状: (4, 2)
```

**过程**：把 B 接在 A 的下面，行数相加 (2+2=4)，列数不变。

### 沿 axis=1 连接（水平拼接）

```python
result = np.concatenate([A, B], axis=1)
print(result)
print("形状:", result.shape)
```

**结果**：

```
[[1 2 5 6]
 [3 4 7 8]]
形状: (2, 4)
```

**过程**：把 B 接在 A 的右边，行数不变，列数相加 (2+2=4)。

## vstack 和 hstack

这是 `concatenate` 的便捷版本，更直观。

### vstack：垂直堆叠

**记忆**：v = vertical（垂直）

```python
A = np.array([[1, 2, 3], [4, 5, 6]])  # (2, 3)
B = np.array([[7, 8, 9]])              # (1, 3)

result = np.vstack([A, B])
print(result)
print("形状:", result.shape)
```

**结果**：

```
[[1 2 3]
 [4 5 6]
 [7 8 9]]
形状: (3, 3)
```

**要求**：列数必须相同。

### hstack：水平堆叠

**记忆**：h = horizontal（水平）

```python
A = np.array([[1, 2, 3], [4, 5, 6]])  # (2, 3)
C = np.array([[10], [20]])             # (2, 1)

result = np.hstack([A, C])
print(result)
print("形状:", result.shape)
```

**结果**：

```
[[ 1  2  3 10]
 [ 4  5  6 20]]
形状: (2, 4)
```

**要求**：行数必须相同。

## stack 沿新轴堆叠

`stack` 会创建一个**新的维度**，把数组沿这个新维度堆叠。

```python
A = np.array([[1, 2], [3, 4]])  # (2, 2)
B = np.array([[5, 6], [7, 8]])  # (2, 2)
```

### 沿 axis=0 堆叠

```python
result = np.stack([A, B], axis=0)
print("形状:", result.shape)  # (2, 2, 2)
print(result)
```

**结果**：

```
形状: (2, 2, 2)
[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
```

**理解**：创建了一个"批次"维度，result[0] 是 A，result[1] 是 B。

**应用场景**：深度学习中把多个样本堆叠成一个 batch。

### 沿 axis=2 堆叠

```python
result = np.stack([A, B], axis=2)
print("形状:", result.shape)  # (2, 2, 2)
```

**理解**：在最后一个维度堆叠，result[:,:,0] 是 A，result[:,:,1] 是 B。

> **注意**：`stack` 要求所有数组形状完全相同！

## dstack 深度堆叠

沿第三个轴（深度方向）堆叠。

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

result = np.dstack([A, B])
print("形状:", result.shape)  # (2, 2, 2)
```

**应用场景**：把多个灰度图合并成彩色图（RGB 三通道）。

## split 分割

`split` 是连接的逆操作，把一个数组分割成多个部分。

```python
arr = np.arange(12).reshape(4, 3)
print(arr)
```

**结果**：

```
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
```

### 均匀分割

```python
# 沿 axis=0 分成 2 份
parts = np.split(arr, 2, axis=0)

print("第 1 部分:\n", parts[0])
print("第 2 部分:\n", parts[1])
```

**结果**：

```
第 1 部分:
 [[0 1 2]
  [3 4 5]]
第 2 部分:
 [[ 6  7  8]
  [ 9 10 11]]
```

**过程**：4 行平均分成 2 份，每份 2 行。

```python
# 沿 axis=1 分成 3 份
parts = np.split(arr, 3, axis=1)
# 返回 3 个 (4, 1) 数组
```

### 指定分割位置

```python
# 在索引 1 和 3 处分割
parts = np.split(arr, [1, 3], axis=0)

print("第 1 部分 ([:1]):\n", parts[0])
print("第 2 部分 ([1:3]):\n", parts[1])
print("第 3 部分 ([3:]):\n", parts[2])
```

**结果**：

```
第 1 部分 ([:1]):
 [[0 1 2]]
第 2 部分 ([1:3]):
 [[3 4 5]
  [6 7 8]]
第 3 部分 ([3:]):
 [[ 9 10 11]]
```

**理解**：`[1, 3]` 表示在索引 1 和 3 处切两刀，分成 3 份。

## vsplit 和 hsplit

```python
arr = np.arange(12).reshape(4, 3)

# vsplit: 垂直分割（按行分）
parts = np.vsplit(arr, 2)  # 分成 2 个 (2, 3) 数组

# hsplit: 水平分割（按列分）
parts = np.hsplit(arr, 3)  # 分成 3 个 (4, 1) 数组
```

## array_split 不均匀分割

当数组不能均匀分割时，用 `array_split`。

```python
arr = np.arange(10)  # [0, 1, 2, ..., 9] 共 10 个元素

# 分成 3 份（不能均分：10÷3 = 3...1）
parts = np.array_split(arr, 3)

print("第 1 部分:", parts[0])
print("第 2 部分:", parts[1])
print("第 3 部分:", parts[2])
```

**结果**：

```
第 1 部分: [0 1 2 3]    # 4 个元素
第 2 部分: [4 5 6]      # 3 个元素
第 3 部分: [7 8 9]      # 3 个元素
```

**规则**：前面的份会多分一些元素。

**对比**：

- `split(arr, 3)` 会报错，因为 10 不能被 3 整除
- `array_split(arr, 3)` 可以工作

## 常用场景

| 场景                   | 方法                              |
| ---------------------- | --------------------------------- |
| 垂直拼接表格（增加行） | `vstack` 或 `concatenate(axis=0)` |
| 水平拼接特征（增加列） | `hstack` 或 `concatenate(axis=1)` |
| 创建批次维度           | `stack(axis=0)`                   |
| 分割训练/测试集        | `split` 或 `array_split`          |
| 合并 RGB 通道          | `dstack` 或 `stack(axis=2)`       |

## 小结

### 连接方法

1. **concatenate**：通用连接，需指定 axis
2. **vstack**：垂直堆叠（axis=0 的简写）
3. **hstack**：水平堆叠（axis=1 的简写）
4. **stack**：创建新维度并堆叠

### 分割方法

1. **split**：均匀分割
2. **vsplit/hsplit**：垂直/水平分割
3. **array_split**：允许不均匀分割

## 练习
1. 创建两个 (3, 4) 矩阵，垂直拼接成 (6, 4) 矩阵
2. 创建两个 (3, 4) 矩阵，水平拼接成 (3, 8) 矩阵
3. 把长度为 17 的数组分成 5 份（使用 array_split）

# 文件操作

## 学习目标

- 掌握 NumPy 数组的保存和加载方法
- 学会读写文本文件
- 理解不同文件格式的特点

## 为什么需要文件操作？

在实际项目中，你需要：

- **保存中间结果**：避免每次重新计算
- **共享数据**：把处理好的数据给其他人用
- **持久化存储**：程序结束后数据不丢失
- **与其他工具交换**：如 Excel、Pandas

## 文件格式对比

| 格式        | 函数                  | 特点                     | 适用场景          |
| ----------- | --------------------- | ------------------------ | ----------------- |
| `.npy`      | `save()/load()`       | 二进制，快速，保留 dtype | 临时存储/快速 I/O |
| `.npz`      | `savez()/load()`      | 压缩的多数组文件         | 存储多个数组      |
| `.txt/.csv` | `savetxt()/loadtxt()` | 文本格式，可读性好       | 与其他程序交换    |

## 二进制文件 (.npy)

### 保存单个数组

```python
arr = np.random.random((3, 4))
print("原始数组:\n", arr)
```

**结果**：

```
原始数组:
 [[0.37454012 0.95071431 0.73199394 0.59865848]
  [0.15601864 0.15599452 0.05808361 0.86617615]
  [0.60111501 0.70807258 0.02058449 0.96990985]]
```

```python
# 保存到文件
np.save('data.npy', arr)
print("已保存到 data.npy")
```

**说明**：

- 文件名自动添加 `.npy` 后缀（如果没有写）
- 保存后会创建一个二进制文件

### 加载数组

```python
# 从文件加载
loaded = np.load('data.npy')
print("加载的数组:\n", loaded)
```

### 验证数据完整性

```python
# 验证数据是否完全一致
print("数据相等:", np.array_equal(arr, loaded))  # True
print("类型保留:", loaded.dtype)  # float64
```

### .npy 格式的优点

1. **速度快**：二进制格式，读写速度最快
2. **文件小**：比文本格式占用空间小
3. **完整保留数据类型**：int32 存进去，读出来还是 int32
4. **支持任意维度**：无论多少维都可以保存

## 多数组文件 (.npz)

当需要保存多个数组时，使用 `.npz` 格式。

```python
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([[1, 2], [3, 4]])
arr3 = np.random.random((2, 3))

# 保存多个数组（使用关键字参数命名）
np.savez('data.npz', x=arr1, matrix=arr2, random=arr3)
print("已保存到 data.npz")
```

**说明**：`x=arr1` 表示把 arr1 命名为 'x' 存储。

### 加载多数组文件

```python
# 加载文件
data = np.load('data.npz')

# 查看包含哪些数组
print("包含的数组:", data.files)  # ['x', 'matrix', 'random']

# 按名称访问
print("x:", data['x'])
print("matrix:\n", data['matrix'])
print("random:\n", data['random'])
```

**结果**：

```
包含的数组: ['x', 'matrix', 'random']
x: [1 2 3 4 5]
matrix:
 [[1 2]
  [3 4]]
random:
 [[0.78227816 0.58985146 0.01292458]
  [0.02946096 0.31286622 0.28756624]]
```

### 压缩版本

```python
# 使用 gzip 压缩（文件更小，但速度稍慢）
np.savez_compressed('data_compressed.npz', x=arr1, matrix=arr2)
```

**使用场景**：数组很大、磁盘空间有限时使用压缩版本。

## 文本文件 (.txt/.csv)

文本格式的优点是人类可读，可以用记事本打开查看。

### 保存为文本

```python
arr = np.array([[1.234, 2.345, 3.456],
                [4.567, 5.678, 6.789],
                [7.890, 8.901, 9.012]])

# 默认格式（科学计数法）
np.savetxt('data.txt', arr)
```

**data.txt 内容**：

```
1.234000000000000e+00 2.345000000000000e+00 3.456000000000000e+00
4.567000000000000e+00 5.678000000000000e+00 6.789000000000000e+00
7.890000000000000e+00 8.901000000000000e+00 9.012000000000000e+00
```

### 自定义格式

```python
np.savetxt('data.csv', arr,
           delimiter=',',     # 分隔符改为逗号
           fmt='%.2f',        # 保留 2 位小数
           header='A,B,C',    # 添加表头
           comments='')       # 不添加 # 注释符
```

**data.csv 内容**：

```
A,B,C
1.23,2.35,3.46
4.57,5.68,6.79
7.89,8.90,9.01
```

**这样的 CSV 文件可以直接用 Excel 打开！**

### 格式说明符

| 格式     | 说明              | 示例         |
| -------- | ----------------- | ------------ |
| `%.2f`   | 2 位小数          | `3.14`       |
| `%.4f`   | 4 位小数          | `3.1416`     |
| `%d`     | 整数              | `3`          |
| `%.2e`   | 科学计数法        | `3.14e+00`   |
| `%10.4f` | 宽度 10，4 位小数 | `    3.1416` |

### 加载文本文件

```python
# 基本加载
arr = np.loadtxt('data.txt')
print(arr)
```

```python
# 加载 CSV 文件
arr = np.loadtxt('data.csv', delimiter=',', skiprows=1)  # 跳过表头
print(arr)
```

**结果**：

```
[[1.23 2.35 3.46]
 [4.57 5.68 6.79]
 [7.89 8.9  9.01]]
```

### loadtxt 常用参数

```python
arr = np.loadtxt(
    'data.csv',
    delimiter=',',     # 分隔符
    skiprows=1,        # 跳过开头 1 行（表头）
    usecols=(0, 2),    # 只读取第 0 和第 2 列
    dtype=np.float32,  # 指定数据类型
)
```

## savetxt 参数详解

```python
np.savetxt(
    fname,           # 文件路径
    X,               # 要保存的数组
    fmt='%.18e',     # 格式字符串
    delimiter=' ',   # 分隔符（默认空格）
    newline='\n',    # 行分隔符
    header='',       # 文件头（第一行注释）
    footer='',       # 文件尾（最后一行注释）
    comments='# '    # 注释前缀
)
```

**常见用法**：

```python
# 保存为整数格式的 CSV
np.savetxt('integers.csv', arr.astype(int), fmt='%d', delimiter=',')

# 保存为科学计数法
np.savetxt('scientific.txt', arr, fmt='%.4e')
```

## loadtxt 参数详解

```python
np.loadtxt(
    fname,           # 文件路径
    dtype=float,     # 数据类型（默认 float）
    delimiter=None,  # 分隔符（None 表示任意空白）
    skiprows=0,      # 跳过开头行数
    usecols=None,    # 读取的列（None 表示全部）
    unpack=False     # 是否转置
)
```

### unpack 参数

```python
# 假设文件有 3 列
# 不使用 unpack
data = np.loadtxt('data.csv', delimiter=',')  # shape: (n, 3)

# 使用 unpack=True
col1, col2, col3 = np.loadtxt('data.csv', delimiter=',', unpack=True)
# 每个变量是一列数据
```

## 使用场景总结

| 场景                   | 推荐方法      | 原因                 |
| ---------------------- | ------------- | -------------------- |
| 临时存储/快速 I/O      | `.npy`        | 速度最快             |
| 存储多个相关数组       | `.npz`        | 一个文件管理多个数组 |
| 与 Excel/其他程序交换  | `.csv`/`.txt` | 通用格式             |
| 需要人工查看/编辑      | `.csv`/`.txt` | 文本可读             |
| 大型数组，磁盘空间紧张 | `.npz` 压缩版 | 节省空间             |

> **性能提示**：对于大型数组，二进制格式 (`.npy`) 比文本格式快 **10-100 倍**。

## 完整示例：数据处理工作流

```python
# 1. 生成或加载原始数据
np.random.seed(42)
raw_data = np.random.random((1000, 10))

# 2. 处理数据
processed_data = (raw_data - raw_data.mean(axis=0)) / raw_data.std(axis=0)

# 3. 保存处理结果
np.save('processed_data.npy', processed_data)
np.savez('all_data.npz', raw=raw_data, processed=processed_data)

# 4. 之后可以直接加载处理后的数据
data = np.load('processed_data.npy')
```

## 小结

1. **二进制格式 (.npy)**：最快，完整保留数据类型，推荐用于 Python 内部
2. **多数组格式 (.npz)**：一个文件存多个数组，支持压缩
3. **文本格式 (.txt/.csv)**：人类可读，适合与其他程序交换
4. **性能考虑**：大数据用二进制，小数据或需要检查时用文本

## 练习
1. 创建一个 100×100 的随机矩阵，保存为 `.npy` 格式，再加载回来验证数据一致
2. 创建两个数组，保存到一个 `.npz` 文件，然后分别加载出来
3. 创建一个 5×3 的整数矩阵，保存为 CSV 格式（带表头 A,B,C），然后用记事本打开查看

# 实用函数

## 学习目标

- 掌握 NumPy 的实用函数
- 学会排序和搜索操作
- 理解集合操作

## 为什么需要实用函数？

在数据处理中，除了基本的数值运算，还经常需要：

- **排序数据**：找出最大最小值，生成排行榜
- **去重统计**：统计不同类别的出现次数
- **集合运算**：找出两个数据集的交集、差集
- **搜索定位**：快速找到满足条件的元素位置

NumPy 提供了丰富的工具函数来高效完成这些任务。

## 排序函数

| 函数              | 说明             | 返回值   |
| ----------------- | ---------------- | -------- |
| `np.sort(arr)`    | 返回排序后的副本 | 新数组   |
| `arr.sort()`      | 原地排序         | None     |
| `np.argsort(arr)` | 返回排序后的索引 | 索引数组 |

### sort 排序

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])
print("原数组:", arr)
```

**结果**：

```
原数组: [3 1 4 1 5 9 2 6]
```

```python
# 方法1: np.sort() - 返回副本，原数组不变
sorted_arr = np.sort(arr)
print("排序后:", sorted_arr)
print("原数组:", arr)  # 原数组不变
```

**结果**：

```
排序后: [1 1 2 3 4 5 6 9]
原数组: [3 1 4 1 5 9 2 6]
```

**说明**：`np.sort()` 是非破坏性操作，返回新数组，原数组保持不变。

```python
# 方法2: arr.sort() - 原地排序，修改原数组
arr.sort()
print("原地排序后:", arr)
```

**结果**：

```
原地排序后: [1 1 2 3 4 5 6 9]
```

**说明**：`arr.sort()` 会直接修改原数组，不返回值。适合不需要保留原数组的场景。

### argsort 排序索引

`argsort` 不返回排序后的值，而是返回**排序后的索引**。这在很多场景下非常有用。

```python
arr = np.array([3, 1, 4, 1, 5])
print("原数组:", arr)

indices = np.argsort(arr)
print("排序索引:", indices)
```

**结果**：

```
原数组: [3 1 4 1 5]
排序索引: [1 3 0 2 4]
```

**理解排序索引**：

- 索引 `1` 对应值 `1`（最小）
- 索引 `3` 对应值 `1`（第二小）
- 索引 `0` 对应值 `3`（第三小）
- 索引 `2` 对应值 `4`（第四小）
- 索引 `4` 对应值 `5`（最大）

```python
# 使用索引重建排序后的数组
print("重建排序:", arr[indices])
```

**结果**：`[1 1 3 4 5]`

**应用场景**：当你需要根据一个数组的顺序来排列另一个数组时。

```python
# 示例：学生成绩排名
names = np.array(['Alice', 'Bob', 'Charlie', 'David'])
scores = np.array([85, 92, 78, 96])

# 按成绩从高到低排名
rank_indices = np.argsort(scores)[::-1]  # [::-1] 反转为降序
print("排名:")
for i, idx in enumerate(rank_indices, 1):
    print(f"  第{i}名: {names[idx]} - {scores[idx]}分")
```

**结果**：

```
排名:
  第1名: David - 96分
  第2名: Bob - 92分
  第3名: Alice - 85分
  第4名: Charlie - 78分
```

### 二维数组排序

```python
arr = np.array([[3, 1, 2],
                [6, 4, 5]])
print("原数组:\n", arr)
```

**结果**：

```
原数组:
 [[3 1 2]
  [6 4 5]]
```

```python
# 每行排序 (axis=1)
print("每行排序:\n", np.sort(arr, axis=1))
```

**结果**：

```
每行排序:
 [[1 2 3]
  [4 5 6]]
```

**过程**：每一行内部独立排序。

```python
# 每列排序 (axis=0)
print("每列排序:\n", np.sort(arr, axis=0))
```

**结果**：

```
每列排序:
 [[3 1 2]
  [6 4 5]]
```

**过程**：每一列内部独立排序（第一行是小值，第二行是大值）。

## 唯一值

`np.unique()` 用于找出数组中的唯一值，同时可以返回各种附加信息。

```python
arr = np.array([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])
print("原数组:", arr)
```

**结果**：`原数组: [1 2 2 3 3 3 4 4 4 4]`

### 基本用法

```python
# 获取唯一值
unique = np.unique(arr)
print("唯一值:", unique)
```

**结果**：`唯一值: [1 2 3 4]`

### 获取首次出现的索引

```python
unique, indices = np.unique(arr, return_index=True)
print("唯一值:", unique)
print("首次出现索引:", indices)
```

**结果**：

```
唯一值: [1 2 3 4]
首次出现索引: [0 1 3 6]
```

**含义**：1 首次出现在索引 0，2 首次出现在索引 1，3 首次出现在索引 3，4 首次出现在索引 6。

### 获取计数

```python
unique, counts = np.unique(arr, return_counts=True)
print("唯一值:", unique)
print("出现次数:", counts)
```

**结果**：

```
唯一值: [1 2 3 4]
出现次数: [1 2 3 4]
```

**含义**：1 出现 1 次，2 出现 2 次，3 出现 3 次，4 出现 4 次。

**应用场景**：统计分类数据的分布，如统计不同类别的样本数量。

```python
# 示例：统计用户评分分布
ratings = np.array([5, 4, 5, 3, 4, 5, 5, 4, 3, 2, 5, 4])
values, counts = np.unique(ratings, return_counts=True)
print("评分分布:")
for v, c in zip(values, counts):
    print(f"  {v}星: {c}人 ({c/len(ratings)*100:.1f}%)")
```

**结果**：

```
评分分布:
  2星: 1人 (8.3%)
  3星: 2人 (16.7%)
  4星: 4人 (33.3%)
  5星: 5人 (41.7%)
```

## 集合操作

NumPy 提供了类似数学集合的操作，用于处理两个数组之间的关系。

```python
a = np.array([1, 2, 3, 4, 5])
b = np.array([3, 4, 5, 6, 7])
print("数组 a:", a)
print("数组 b:", b)
```

### 交集

```python
# 交集：同时在 a 和 b 中的元素
result = np.intersect1d(a, b)
print("交集:", result)
```

**结果**：`交集: [3 4 5]`

**图示**：

```
a: {1, 2, 3, 4, 5}
b:       {3, 4, 5, 6, 7}
交集:     {3, 4, 5}
```

### 并集

```python
# 并集：a 或 b 中的所有元素（不重复）
result = np.union1d(a, b)
print("并集:", result)
```

**结果**：`并集: [1 2 3 4 5 6 7]`

### 差集

```python
# 差集：在 a 中但不在 b 中的元素
result = np.setdiff1d(a, b)
print("差集 (a - b):", result)
```

**结果**：`差集 (a - b): [1 2]`

```python
# 反向差集
result = np.setdiff1d(b, a)
print("差集 (b - a):", result)
```

**结果**：`差集 (b - a): [6 7]`

### 对称差集

```python
# 对称差集：只在 a 或只在 b 中的元素（不包括交集）
result = np.setxor1d(a, b)
print("对称差集:", result)
```

**结果**：`对称差集: [1 2 6 7]`

**图示**：

```
a: {1, 2, 3, 4, 5}
b:       {3, 4, 5, 6, 7}
对称差集: {1, 2}     +     {6, 7} = {1, 2, 6, 7}
```

### 成员检测

```python
# 检测 a 中的元素是否在给定列表中
result = np.in1d(a, [2, 4])
print("a 中元素是否在 [2, 4] 中:", result)
```

**结果**：`a 中元素是否在 [2, 4] 中: [False  True False  True False]`

**含义**：a 中的 2 和 4 在列表 `[2, 4]` 中，其他元素不在。

**应用场景**：数据过滤、用户分组、A/B 测试中的用户分配等。

## 搜索函数

| 函数                  | 说明               | 返回值   |
| --------------------- | ------------------ | -------- |
| `np.where(condition)` | 返回满足条件的索引 | 索引元组 |
| `np.argmax(arr)`      | 最大值的索引       | 整数     |
| `np.argmin(arr)`      | 最小值的索引       | 整数     |
| `np.nonzero(arr)`     | 非零元素的索引     | 索引元组 |

```python
arr = np.array([1, 5, 2, 8, 3, 9, 4, 7])
print("数组:", arr)
```

**结果**：`数组: [1 5 2 8 3 9 4 7]`

### argmax 和 argmin

```python
# 找最大值的索引
max_idx = np.argmax(arr)
print(f"最大值索引: {max_idx}, 最大值: {arr[max_idx]}")
```

**结果**：`最大值索引: 5, 最大值: 9`

```python
# 找最小值的索引
min_idx = np.argmin(arr)
print(f"最小值索引: {min_idx}, 最小值: {arr[min_idx]}")
```

**结果**：`最小值索引: 0, 最小值: 1`

**二维数组的 argmax**：

```python
arr_2d = np.array([[1, 5, 3],
                   [4, 2, 6]])
print("二维数组:\n", arr_2d)

# 全局最大值索引（展平后的索引）
print("全局最大值索引:", np.argmax(arr_2d))  # 5 (展平后第6个元素)

# 每列最大值索引
print("每列最大值索引:", np.argmax(arr_2d, axis=0))  # [1 0 1]

# 每行最大值索引
print("每行最大值索引:", np.argmax(arr_2d, axis=1))  # [1 2]
```

### where 条件搜索

```python
arr = np.array([1, 5, 2, 8, 3, 9, 4, 7])

# 找出大于 5 的元素索引
indices = np.where(arr > 5)
print("大于 5 的索引:", indices[0])
print("对应的值:", arr[indices])
```

**结果**：

```
大于 5 的索引: [3 5 7]
对应的值: [8 9 7]
```

**说明**：索引 3、5、7 位置的元素（8、9、7）大于 5。

### nonzero 非零元素

```python
arr = np.array([0, 1, 0, 2, 0, 3])
indices = np.nonzero(arr)
print("非零元素索引:", indices[0])
print("非零元素值:", arr[indices])
```

**结果**：

```
非零元素索引: [1 3 5]
非零元素值: [1 2 3]
```

**应用场景**：稀疏矩阵处理、找出有效数据的位置。

## 裁剪和取整

### clip 裁剪

`clip` 将数组中的值限制在指定范围内，超出范围的值会被截断到边界值。

```python
arr = np.array([1, 5, 10, 15, 20])
print("原数组:", arr)

# 裁剪到 [5, 15] 范围
clipped = np.clip(arr, 5, 15)
print("裁剪后:", clipped)
```

**结果**：

```
原数组: [ 1  5 10 15 20]
裁剪后: [ 5  5 10 15 15]
```

**过程**：

- 1 < 5，被裁剪为 5
- 5 在范围内，保持不变
- 10 在范围内，保持不变
- 15 在范围内，保持不变
- 20 > 15，被裁剪为 15

**应用场景**：

- 图像处理：像素值限制在 [0, 255]
- 机器学习：梯度裁剪防止梯度爆炸
- 数据预处理：异常值处理

```python
# 实际应用：像素值裁剪
pixels = np.array([-10, 50, 128, 200, 300])
valid_pixels = np.clip(pixels, 0, 255)
print("有效像素:", valid_pixels)  # [  0  50 128 200 255]
```

### 取整函数

```python
arr = np.array([1.2, 2.5, 3.7, -1.2, -2.5])
print("原数组:", arr)
```

**结果**：`原数组: [ 1.2  2.5  3.7 -1.2 -2.5]`

```python
# floor: 向下取整（向负无穷方向）
print("向下取整:", np.floor(arr))
```

**结果**：`向下取整: [ 1.  2.  3. -2. -3.]`

**理解**：每个数取不大于它的最大整数。-2.5 向下是 -3。

```python
# ceil: 向上取整（向正无穷方向）
print("向上取整:", np.ceil(arr))
```

**结果**：`向上取整: [ 2.  3.  4. -1. -2.]`

**理解**：每个数取不小于它的最小整数。-2.5 向上是 -2。

```python
# round: 四舍五入
print("四舍五入:", np.round(arr))
```

**结果**：`四舍五入: [ 1.  2.  4. -1. -2.]`

**注意**：NumPy 使用"银行家舍入"，2.5 会舍入到 2（最近的偶数）。

```python
# trunc: 截断取整（向零方向）
print("截断取整:", np.trunc(arr))
```

**结果**：`截断取整: [ 1.  2.  3. -1. -2.]`

**理解**：直接去掉小数部分。-2.5 截断是 -2。

**取整函数对比**：

| 函数    | 1.2 | 2.5 | 3.7 | -1.2 | -2.5 | 方向     |
| ------- | --- | --- | --- | ---- | ---- | -------- |
| `floor` | 1   | 2   | 3   | -2   | -3   | 向负无穷 |
| `ceil`  | 2   | 3   | 4   | -1   | -2   | 向正无穷 |
| `round` | 1   | 2   | 4   | -1   | -2   | 最近整数 |
| `trunc` | 1   | 2   | 3   | -1   | -2   | 向零     |

## 复制操作

理解 NumPy 的复制机制对于避免 bug 非常重要。

| 方式            | 类型   | 修改是否影响原数组 | 内存占用 |
| --------------- | ------ | ------------------ | -------- |
| `arr_ref = arr` | 引用   | 是                 | 无新开销 |
| `arr.view()`    | 视图   | 是                 | 无新开销 |
| `arr.copy()`    | 深拷贝 | 否                 | 双倍内存 |

### 引用

```python
arr = np.array([1, 2, 3, 4, 5])
print("原数组:", arr)

# 引用：只是给同一个数组起了别名
arr_ref = arr
arr_ref[0] = 100

print("修改 arr_ref[0] = 100 后:")
print("  arr_ref:", arr_ref)
print("  arr:    ", arr)
```

**结果**：

```
原数组: [1 2 3 4 5]
修改 arr_ref[0] = 100 后:
  arr_ref: [100   2   3   4   5]
  arr:     [100   2   3   4   5]
```

**原理**：`arr_ref` 和 `arr` 指向同一块内存，修改一个会影响另一个。

### 视图

```python
arr = np.array([1, 2, 3, 4, 5])

# 视图：共享数据，但可以有不同的形状
arr_view = arr.view()
arr_view[1] = 200

print("修改 arr_view[1] = 200 后:")
print("  arr_view:", arr_view)
print("  arr:     ", arr)
```

**结果**：

```
修改 arr_view[1] = 200 后:
  arr_view: [  1 200   3   4   5]
  arr:      [  1 200   3   4   5]
```

**说明**：视图和原数组共享同一块数据，切片操作返回的也是视图。

### 副本（深拷贝）

```python
arr = np.array([1, 2, 3, 4, 5])

# 副本：完全独立的新数组
arr_copy = arr.copy()
arr_copy[2] = 300

print("修改 arr_copy[2] = 300 后:")
print("  arr_copy:", arr_copy)
print("  arr:     ", arr)
```

**结果**：

```
修改 arr_copy[2] = 300 后:
  arr_copy: [  1   2 300   4   5]
  arr:      [1 2 3 4 5]
```

**说明**：副本是完全独立的，修改副本不会影响原数组。

**何时使用 copy()？**

- 需要保留原始数据时
- 将切片结果传递给其他函数前
- 不确定后续操作是否会修改数组时

## 其他实用函数

### 数组比较

| 函数                   | 说明                       | 返回值 |
| ---------------------- | -------------------------- | ------ |
| `np.array_equal(a, b)` | 判断两数组是否完全相同     | bool   |
| `np.allclose(a, b)`    | 判断两数组是否接近（浮点） | bool   |

```python
a = np.array([1, 2, 3])
b = np.array([1, 2, 3])
c = np.array([1, 2, 4])

print("a == b:", np.array_equal(a, b))  # True
print("a == c:", np.array_equal(a, c))  # False
```

**浮点数比较**：

```python
# 浮点数直接比较可能有问题
a = np.array([0.1 + 0.2])
b = np.array([0.3])

print("直接比较:", np.array_equal(a, b))  # False（浮点精度问题）
print("近似比较:", np.allclose(a, b))     # True
```

**说明**：由于浮点数精度问题，`0.1 + 0.2` 不完全等于 `0.3`，但 `allclose` 允许微小误差。

### 逻辑判断

```python
arr = np.array([True, False, True, False])

# any: 是否有任意 True
print("有任意 True:", np.any(arr))  # True

# all: 是否全为 True
print("是否全 True:", np.all(arr))  # False
```

**常见用法**：

```python
scores = np.array([85, 92, 78, 65, 88])

# 检查是否有不及格的
print("有人不及格:", np.any(scores < 60))  # False

# 检查是否全部及格
print("全部及格:", np.all(scores >= 60))  # True

# 检查是否全部优秀
print("全部优秀:", np.all(scores >= 90))  # False
```

## 小结

### 排序与搜索

1. **np.sort()**：返回排序副本
2. **arr.sort()**：原地排序
3. **np.argsort()**：返回排序索引（非常有用！）
4. **np.argmax()/argmin()**：找极值的索引

### 唯一值与集合

1. **np.unique()**：去重，可返回计数
2. **np.intersect1d()**：交集
3. **np.union1d()**：并集
4. **np.setdiff1d()**：差集

### 数值处理

1. **np.clip()**：值裁剪到指定范围
2. **np.floor/ceil/round/trunc()**：不同的取整方式

### 复制操作

1. **引用和视图**：共享内存，修改会相互影响
2. **copy()**：创建独立副本，安全但占用更多内存

## 练习
1. 给定数组 `[3, 1, 4, 1, 5, 9, 2, 6]`，找出前 3 大的元素及其索引
2. 统计数组 `[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]` 中每个元素的出现次数
3. 给定两个用户 ID 列表，找出两个列表的共同用户和只在第一个列表中的用户

# 综合实战

## 学习目标

- 综合运用所学的 NumPy 知识
- 解决实际问题
- 提高编程能力

## 实战项目

| 项目         | 涉及知识点                     | 难度   |
| ------------ | ------------------------------ | ------ |
| 学生成绩分析 | 数组创建、统计运算、排序、索引 | ⭐     |
| 线性回归实现 | 线性代数、矩阵运算、统计分析   | ⭐⭐   |
| 图像操作模拟 | 数组变形、切片、翻转           | ⭐     |
| 统计分析     | 随机数、百分位数、直方图       | ⭐     |
| 移动平均     | 滑动窗口、卷积运算             | ⭐⭐   |
| 矩阵分解     | 线性代数、特征值、SVD          | ⭐⭐⭐ |

---

## 项目 1: 学生成绩分析

### 任务目标

分析 5 名学生 3 门课程的成绩：

- 计算每个学生的总分和平均分
- 计算每门课程的统计信息
- 找出最高分和最低分的学生
- 按总分排名

### 示例代码

```python
np.random.seed(42)

# 创建成绩数据 (5 学生 x 3 课程)
grades = np.random.randint(60, 101, size=(5, 3))
students = ['学生A', '学生B', '学生C', '学生D', '学生E']
courses = ['数学', '英语', '物理']

# 计算每个学生的总分和平均分
total_scores = np.sum(grades, axis=1)
avg_scores = np.mean(grades, axis=1)

# 计算每门课程的统计信息
course_mean = np.mean(grades, axis=0)
course_std = np.std(grades, axis=0)

# 找出总分最高的学生
best_idx = np.argmax(total_scores)
print(f"总分最高: {students[best_idx]}")

# 按总分排名
rank_indices = np.argsort(total_scores)[::-1]
for rank, idx in enumerate(rank_indices, 1):
    print(f"第{rank}名: {students[idx]}")
```

---

## 项目 2: 线性回归实现

### 任务目标

使用正规方程实现最小二乘法线性回归：

- 生成带噪声的线性数据
- 计算回归系数
- 评估模型性能 (R², RMSE)

### 正规方程

$$
\hat{\mathbf{w}} = (\mathbf{X}^T \mathbf{X})^{-1} \mathbf{X}^T \mathbf{y}
$$

### 示例代码

```python
np.random.seed(42)

# 生成数据: y = 2x + 1 + 噪声
n = 50
x = np.linspace(0, 10, n)
y = 2 * x + 1 + np.random.normal(0, 1, n)

# 构建设计矩阵
X = np.column_stack([np.ones(n), x])

# 正规方程求解
XTX = X.T @ X
XTy = X.T @ y
w = np.linalg.solve(XTX, XTy)

intercept, slope = w[0], w[1]
print(f"估计: y = {slope:.4f}x + {intercept:.4f}")

# 计算 R²
y_pred = slope * x + intercept
ss_res = np.sum((y - y_pred) ** 2)
ss_tot = np.sum((y - np.mean(y)) ** 2)
r_squared = 1 - ss_res / ss_tot
print(f"R²: {r_squared:.4f}")
```

---

## 项目 3: 图像操作模拟

### 任务目标

模拟基本图像操作：

- 图像翻转（水平、垂直）
- 图像旋转
- 图像裁剪
- 图像归一化

### 示例代码

```python
# 创建模拟图像 (8x8 灰度图)
image = np.random.randint(0, 256, size=(8, 8), dtype=np.uint8)

# 水平翻转
flipped_h = image[:, ::-1]

# 垂直翻转
flipped_v = image[::-1, :]

# 旋转 90 度
rotated = np.rot90(image)

# 裁剪
cropped = image[2:6, 2:6]

# 归一化到 [0, 1]
normalized = image.astype(np.float64) / 255.0
```

---

## 项目 4: 统计分析

### 任务目标

对正态分布数据进行统计分析：

- 计算基本统计量
- 计算百分位数
- 生成直方图

### 示例代码

```python
np.random.seed(42)

# 生成正态分布数据
data = np.random.normal(loc=100, scale=15, size=1000)

# 基本统计量
print(f"均值: {data.mean():.2f}")
print(f"标准差: {data.std():.2f}")
print(f"最小值: {data.min():.2f}")
print(f"最大值: {data.max():.2f}")

# 百分位数
for p in [25, 50, 75, 90, 95]:
    print(f"第{p}百分位: {np.percentile(data, p):.2f}")

# 直方图
hist, bin_edges = np.histogram(data, bins=10)
```

---

## 项目 5: 移动平均实现

### 任务目标

实现时间序列数据的移动平均：

- 简单移动平均（SMA）
- 加权移动平均（WMA）
- 使用卷积实现

### 示例代码

```python
np.random.seed(42)

# 生成时间序列数据
data = np.cumsum(np.random.randn(100)) + 100

# 简单移动平均 (窗口大小=5)
window = 5
sma = np.convolve(data, np.ones(window)/window, mode='valid')

# 加权移动平均 (近期权重更大)
weights = np.arange(1, window+1)
weights = weights / weights.sum()
wma = np.convolve(data, weights[::-1], mode='valid')

print(f"原始数据前10个: {data[:10]}")
print(f"SMA前5个: {sma[:5]}")
print(f"WMA前5个: {wma[:5]}")
```

---

## 项目 6: 矩阵分解应用

### 任务目标

实现矩阵分解技术：

- 奇异值分解（SVD）
- 主成分分析（PCA）
- 数据降维

### SVD 公式

$$
\mathbf{A} = \mathbf{U} \mathbf{\Sigma} \mathbf{V}^T
$$

### 示例代码

```python
np.random.seed(42)

# 创建数据矩阵 (100 样本 x 10 特征)
data = np.random.randn(100, 10)

# 中心化数据
data_centered = data - data.mean(axis=0)

# SVD 分解
U, S, Vt = np.linalg.svd(data_centered, full_matrices=False)

# 计算方差解释比例
variance_explained = (S ** 2) / (S ** 2).sum()
cumsum_variance = np.cumsum(variance_explained)

print("前5个成分的方差解释率:")
for i in range(5):
    print(f"  PC{i+1}: {variance_explained[i]:.4f} (累积: {cumsum_variance[i]:.4f})")

# 降维到2维
n_components = 2
data_reduced = U[:, :n_components] @ np.diag(S[:n_components])
print(f"\n降维后形状: {data_reduced.shape}")
```

---

## 性能优化技巧

### 1. 向量化运算

```python
# ❌ 慢速：使用循环
result = np.zeros(1000000)
for i in range(len(result)):
    result[i] = i ** 2

# ✅ 快速：向量化
arr = np.arange(1000000)
result = arr ** 2
```

### 2. 就地操作

```python
# ❌ 创建新数组
arr = arr + 5

# ✅ 就地修改
arr += 5
```

### 3. 选择合适的数据类型

```python
# ❌ 使用默认 float64
arr = np.random.rand(1000, 1000)

# ✅ 根据需求选择
arr = np.random.rand(1000, 1000).astype(np.float32)
```

### 4. 使用视图而非副本

```python
# ✅ 创建视图（共享内存）
view = arr[::2]

# ❌ 创建副本（新内存）
copy = arr[::2].copy()
```

---

## 常见错误与解决方案

### 错误 1: 形状不匹配

```python
# ❌ 错误
a = np.array([1, 2, 3])
b = np.array([[1], [2], [3], [4]])
result = a + b  # 无法广播

# ✅ 正确
a = np.array([[1, 2, 3]])  # 变为 (1, 3)
b = np.array([[1], [2], [3], [4]])  # (4, 1)
result = a + b  # 广播为 (4, 3)
```

### 错误 2: 整数除法

```python
# ❌ 整数除法返回整数
arr = np.array([1, 2, 3])
result = arr / 2  # [0, 1, 1]

# ✅ 转换为浮点数
result = arr / 2.0  # [0.5, 1.0, 1.5]
```

### 错误 3: 视图 vs 副本

```python
# ❌ 意外修改原数组
arr = np.array([1, 2, 3, 4])
view = arr[:2]
view[0] = 999
print(arr)  # [999, 2, 3, 4]

# ✅ 使用副本
copy = arr[:2].copy()
copy[0] = 999
print(arr)  # [1, 2, 3, 4]
```

### 错误 4: 数组比较

```python
# ❌ 错误的比较方式
arr1 = np.array([1, 2, 3])
arr2 = np.array([1, 2, 3])
if arr1 == arr2:  # 报错！
    pass

# ✅ 正确的比较
if np.array_equal(arr1, arr2):
    print("数组相等")

# ✅ 元素级比较
comparison = arr1 == arr2  # 返回布尔数组
if np.all(comparison):
    print("所有元素相等")
```

---

## 实用技巧速查

### 数组创建技巧

```python
# 创建对角矩阵
np.diag([1, 2, 3])

# 创建单位矩阵
np.eye(3)

# 从函数创建
np.fromfunction(lambda i, j: i + j, (3, 3))

# 重复数组
np.repeat([1, 2, 3], 3)  # [1, 1, 1, 2, 2, 2, 3, 3, 3]
np.tile([1, 2, 3], 3)    # [1, 2, 3, 1, 2, 3, 1, 2, 3]
```

### 高级索引技巧

```python
# 多条件筛选
arr[(arr > 5) & (arr < 10)]

# 花式索引
arr[[0, 2, 4]]  # 取第0、2、4个元素

# 网格索引
rows = np.array([0, 1])
cols = np.array([0, 2])
arr[np.ix_(rows, cols)]
```

### 统计函数技巧

```python
# 去除异常值
q1, q3 = np.percentile(data, [25, 75])
iqr = q3 - q1
filtered = data[(data >= q1 - 1.5*iqr) & (data <= q3 + 1.5*iqr)]

# 标准化
standardized = (data - data.mean()) / data.std()

# 归一化到 [0, 1]
normalized = (data - data.min()) / (data.max() - data.min())
```

### 数组操作技巧

```python
# 交换轴
np.swapaxes(arr, 0, 1)

# 扩展维度
arr[np.newaxis, :]  # 在前面添加维度
arr[:, np.newaxis]  # 在后面添加维度

# 压缩维度
np.squeeze(arr)  # 移除长度为1的维度

# 数组拼接
np.concatenate([arr1, arr2], axis=0)
np.vstack([arr1, arr2])  # 垂直拼接
np.hstack([arr1, arr2])  # 水平拼接
```

---

## 总结：常用技巧速查

### 数组创建与初始化

```python
# 快速创建
np.zeros((3, 4))          # 全零
np.ones((3, 4))           # 全一
np.full((3, 4), 7)        # 填充指定值
np.empty((3, 4))          # 空数组（未初始化）
np.arange(0, 10, 2)       # 等差数列 [0, 2, 4, 6, 8]
np.linspace(0, 1, 5)      # 等分数列 [0, 0.25, 0.5, 0.75, 1]
np.logspace(0, 2, 5)      # 对数空间 [1, 10, 100]

# 特殊矩阵
np.eye(3)                 # 单位矩阵
np.diag([1, 2, 3])        # 对角矩阵
np.tri(3)                 # 下三角矩阵
```

### 形状操作

```python
arr.reshape(3, 4)         # 变形
arr.resize((3, 4))        # 就地变形
arr.flatten()             # 展平（副本）
arr.ravel()               # 展平（尽可能返回视图）
arr.T                     # 转置
arr.transpose(1, 0)       # 指定轴转置
arr.squeeze()             # 移除长度为1的维度
np.expand_dims(arr, 0)    # 增加维度
```

### 统计运算

```python
arr.sum(axis=0)           # 按列求和
arr.mean(axis=1)          # 按行求均值
arr.std(ddof=1)           # 样本标准差
arr.var()                 # 方差
arr.max(), arr.argmax()   # 最大值及索引
arr.min(), arr.argmin()   # 最小值及索引
arr.cumsum()              # 累积和
arr.cumprod()             # 累积积
np.percentile(arr, 50)    # 中位数
np.median(arr)            # 中位数（另一种方法）
np.corrcoef(x, y)         # 相关系数
```

### 条件操作

```python
arr[arr > 5]              # 布尔索引
np.where(arr > 5)         # 返回索引
np.where(arr > 5, 1, 0)   # 条件替换
np.any(arr > 5)           # 任意满足
np.all(arr > 5)           # 全部满足
np.isnan(arr)             # 检查 NaN
np.isinf(arr)             # 检查无穷
np.nonzero(arr)           # 非零元素索引
```

### 数组合并与分割

```python
np.concatenate([a, b])    # 拼接
np.vstack([a, b])         # 垂直拼接
np.hstack([a, b])         # 水平拼接
np.dstack([a, b])         # 深度拼接
np.split(arr, 3)          # 等分
np.array_split(arr, 3)    # 不等分（允许）
np.hsplit(arr, 3)         # 水平分割
np.vsplit(arr, 3)         # 垂直分割
```

### 线性代数

```python
np.dot(a, b)              # 矩阵乘法
a @ b                     # 矩阵乘法（Python 3.5+）
np.linalg.inv(a)          # 矩阵求逆
np.linalg.det(a)          # 行列式
np.linalg.eig(a)          # 特征值和特征向量
np.linalg.svd(a)          # 奇异值分解
np.linalg.solve(A, b)     # 求解线性方程组
np.linalg.norm(a)         # 范数
np.trace(a)               # 迹
```

---

## 调试技巧

### 查看数组信息

```python
arr.shape                 # 形状
arr.dtype                 # 数据类型
arr.ndim                  # 维度数
arr.size                  # 元素总数
arr.itemsize              # 每个元素字节数
arr.nbytes                # 总字节数
arr.flags                 # 数组标志
```

### 设置打印选项

```python
# 控制打印格式
np.set_printoptions(
    precision=4,          # 小数精度
    suppress=True,        # 不使用科学计数法
    threshold=10,         # 超过10个元素时省略
    edgeitems=2,          # 省略时显示边缘元素数
    linewidth=100         # 每行字符数
)

# 查看完整数组
with np.printoptions(threshold=np.inf):
    print(arr)
```

### 内存管理

```python
# 检查是否共享内存
arr2.base is arr          # 如果是视图，返回 True

# 强制创建副本
arr2 = arr.copy()

# 查看内存地址
arr.__array_interface__['data'][0]
```

---

## 进阶学习建议

### 1. 深入学习资源

- **官方文档**：
  - NumPy 用户指南：https://numpy.org/doc/stable/user/
  - NumPy API 参考：https://numpy.org/doc/stable/reference/
- **进阶主题**：
  - 结构化数组（Structured Arrays）：处理表格数据
  - 记录数组（Record Arrays）：命名字段访问
  - 内存布局：C-order vs Fortran-order 的性能影响
  - NumPy C API：与 C/C++ 代码交互
  - 掩码数组（Masked Arrays）：处理缺失值

- **书籍推荐**：
  - 《Python for Data Analysis》by Wes McKinney
  - 《NumPy Essentials》by Leo (Liang-Huan) Chin

### 2. 相关库学习路径

```
NumPy (数值计算基础)
    ↓
├─→ Pandas (数据分析)
│       ↓
│   ├─→ Scikit-learn (机器学习)
│   └─→ Statsmodels (统计建模)
│
├─→ Matplotlib/Seaborn (数据可视化)
│
├─→ SciPy (科学计算)
│       ↓
│   └─→ SymPy (符号计算)
│
└─→ TensorFlow/PyTorch (深度学习)
```

**推荐学习顺序**：

1. **Pandas**：处理表格数据、时间序列
2. **Matplotlib**：数据可视化
3. **Scikit-learn**：机器学习算法
4. **SciPy**：高级科学计算

### 3. 实践项目建议

#### 入门级项目

- 图像处理：图像滤波、边缘检测
- 数据清洗：缺失值处理、异常值检测
- 简单统计分析：描述性统计、假设检验

#### 中级项目

- 实现机器学习算法：KNN、决策树
- 时间序列分析：ARIMA 模型
- 信号处理：傅里叶变换、滤波器设计

#### 高级项目

- 神经网络：从零实现反向传播
- 计算机视觉：目标检测算法
- 数值优化：梯度下降变体实现

### 4. 性能优化进阶

```python
# 使用 numexpr 加速表达式计算
import numexpr as ne
result = ne.evaluate('a + b * c')

# 使用 numba 进行 JIT 编译
from numba import jit

@jit(nopython=True)
def fast_function(arr):
    total = 0
    for i in range(arr.shape[0]):
        total += arr[i]
    return total

# 使用 Cython 优化关键代码
# 查看 Cython 文档了解更多
```

### 5. 常见面试题

1. **NumPy 数组与 Python 列表的区别**
   - 类型一致性、内存连续、向量化运算

2. **什么是广播机制**
   - 不同形状数组的运算规则

3. **视图 vs 副本的区别**
   - 内存共享、修改影响

4. **如何优化 NumPy 代码性能**
   - 向量化、数据类型、避免循环

5. **NumPy 中的轴（axis）如何理解**
   - axis=0 沿着行、axis=1 沿着列

---

## 学习检查清单

完成以下检查项，确保掌握 NumPy 核心知识：

- [ ] 能熟练创建各种类型的数组
- [ ] 理解数组的形状、维度、数据类型
- [ ] 掌握切片、索引、花式索引
- [ ] 理解广播机制并能应用
- [ ] 会使用向量化运算替代循环
- [ ] 能进行数组变形和转置
- [ ] 掌握常用统计函数
- [ ] 理解视图和副本的区别
- [ ] 会使用布尔索引进行条件筛选
- [ ] 能进行基本的线性代数运算
- [ ] 了解随机数生成和统计分布
- [ ] 能读写 NumPy 数组文件
- [ ] 理解内存布局和性能优化

---

## 快速参考卡片

### 最常用的 20 个函数

| 函数               | 用途       | 示例                        |
| ------------------ | ---------- | --------------------------- |
| `np.array()`       | 创建数组   | `np.array([1, 2, 3])`       |
| `np.zeros()`       | 全零数组   | `np.zeros((3, 4))`          |
| `np.ones()`        | 全一数组   | `np.ones((2, 3))`           |
| `np.arange()`      | 等差序列   | `np.arange(0, 10, 2)`       |
| `np.linspace()`    | 等分序列   | `np.linspace(0, 1, 5)`      |
| `np.random.rand()` | 随机数组   | `np.random.rand(3, 4)`      |
| `arr.reshape()`    | 变形       | `arr.reshape(2, -1)`        |
| `arr.T`            | 转置       | `arr.T`                     |
| `np.concatenate()` | 拼接       | `np.concatenate([a, b])`    |
| `arr.sum()`        | 求和       | `arr.sum(axis=0)`           |
| `arr.mean()`       | 均值       | `arr.mean()`                |
| `arr.max()`        | 最大值     | `arr.max(axis=1)`           |
| `arr.argmax()`     | 最大值索引 | `arr.argmax()`              |
| `np.where()`       | 条件选择   | `np.where(arr > 0, 1, -1)`  |
| `np.dot()`         | 矩阵乘法   | `np.dot(a, b)`              |
| `np.linalg.inv()`  | 矩阵求逆   | `np.linalg.inv(A)`          |
| `np.save()`        | 保存数组   | `np.save('data.npy', arr)`  |
| `np.load()`        | 加载数组   | `arr = np.load('data.npy')` |
| `arr[arr > 0]`     | 布尔索引   | `arr[arr > 0]`              |
| `arr[[0, 2]]`      | 花式索引   | `arr[[0, 2, 4]]`            |

---

🎉 **恭喜你完成了 NumPy 学习教程！**

### 下一步行动

1. **立即实践**：运行完整演示代码

   ```bash
   python Basic/Numpy/12_practice.py
   ```

2. **巩固练习**：尝试以下挑战
   - 实现 K-means 聚类算法
   - 编写图像卷积函数
   - 实现梯度下降优化器

3. **深入学习**：
   - 阅读 NumPy 源码中感兴趣的部分
   - 研究 NumPy 底层 C API
   - 学习 BLAS/LAPACK 线性代数库

4. **分享交流**：
   - 在 GitHub 上分享你的实践项目
   - 参与 Stack Overflow 问答
   - 为开源项目贡献代码

### 学习资源汇总

- **官方资源**：
  - NumPy 官网：https://numpy.org/
  - 用户指南：https://numpy.org/doc/stable/user/
  - API 参考：https://numpy.org/doc/stable/reference/

- **教程与课程**：
  - NumPy 快速入门：https://numpy.org/doc/stable/user/quickstart.html
  - NumPy 101：https://numpy.org/numpy-tutorials/

- **社区资源**：
  - Stack Overflow：标签 [numpy]
  - Reddit：r/Python, r/learnpython
  - GitHub：https://github.com/numpy/numpy

### 反馈与改进

如果你发现文档中的错误或有改进建议，欢迎：

- 提交 Issue
- 发起 Pull Request
- 联系文档维护者

---

**持续学习，不断进步！** 🚀
