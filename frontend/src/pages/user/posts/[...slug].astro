---
export const prerender = false;

import fs from 'node:fs/promises';
import path from 'node:path';
import matter from 'gray-matter';
import { marked } from 'marked';
import markedKatex from 'marked-katex-extension';
import { createHighlighter, type Highlighter } from 'shiki';
import MarkdownLayout from '../../../layouts/MarkdownLayout.astro';

// 缓存 Shiki highlighter 实例（单例模式）
let cachedHighlighter: Highlighter | null = null;
async function getHighlighter() {
  if (!cachedHighlighter) {
    cachedHighlighter = await createHighlighter({
      themes: ['github-light'],
      langs: ['javascript', 'typescript', 'python', 'html', 'css', 'json', 'bash', 'shell', 'markdown']
    });
  }
  return cachedHighlighter;
}

const { slug } = Astro.params;
const decodedSlug = decodeURIComponent(slug || '');

if (!slug) {
  return Astro.redirect('/404');
}

// Define the content directory
// Handle running from root or frontend directory
let contentDir = path.join(process.cwd(), 'blog');
try {
  await fs.access(contentDir);
} catch {
  contentDir = path.join(process.cwd(), 'frontend/blog');
}

// Try to find the file with .md or .mdx extension
let filePath = path.join(contentDir, `${decodedSlug}.md`);
let fileContent = '';

try {
  try {
    fileContent = await fs.readFile(filePath, 'utf-8');
  } catch (e) {
    // Try .mdx if .md fails
    filePath = path.join(contentDir, `${decodedSlug}.mdx`);
    fileContent = await fs.readFile(filePath, 'utf-8');
  }
} catch (e) {
  console.error(`Post not found: ${decodedSlug}`, e);
  return Astro.redirect('/404');
}

// Parse frontmatter and content
const { data: frontmatter, content } = matter(fileContent);

// Configure marked to match Astro's output structure for CSS compatibility
const renderer = new marked.Renderer();

// 使用缓存的 highlighter 实例
const highlighter = await getHighlighter();

// Custom code block renderer to add 'astro-code' class and syntax highlighting
renderer.code = ({ text, lang }) => {
  const language = lang || 'plaintext';
  try {
    const html = highlighter.codeToHtml(text, {
      lang: language,
      theme: 'github-light'
    });
    // Shiki returns a <pre>...</pre> block. We need to ensure it has the classes our CSS expects.
    // Our CSS expects: pre.astro-code
    // Shiki output usually looks like: <pre class="shiki github-light" ...>
    // Or in newer versions: <pre class="shiki shiki-themes github-light" ...>
    // We use a regex to replace the class attribute safely
    return html.replace(/class="shiki[^"]*"/, `class="astro-code github-light language-${language}"`);
  } catch (e) {
    // Fallback if language not found
    return `<pre class="astro-code language-${language}"><code>${text}</code></pre>`;
  }
};

// Configure marked options
marked.use(markedKatex({
  throwOnError: false,
  displayMode: true, // Support block-level math with $$...$$
  output: 'html'
}));

marked.use({ 
  renderer, 
  gfm: true, // GitHub Flavored Markdown
  breaks: false // Disable breaks to prevent <br> inside math blocks
});

// Preprocess content to ensure $$ blocks are properly formatted
// marked-katex-extension requires empty lines before and after $$ blocks
function preprocessMathBlocks(text: string): string {
  // Normalize line endings to \n (handle Windows CRLF)
  let result = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  
  // Fix inline math followed by ( without space (e.g., $D^1$(...) should be $D^1$ (...))
  // In JS replace: $$ outputs literal $, so $$$$1$$ means $[group1]$
  result = result.replace(/\$([^$\n]+)\$\(/g, '$$$$1$$ (');
  
  // Process $$ blocks: ensure empty lines before and after
  // Match: newline, $$, newline, content, newline, $$, end
  result = result.replace(/(\n)(\$\$)\n([\s\S]*?)\n(\$\$)(\n|$)/g, (match, before, open, content, close, after) => {
    // Ensure opening $$ has empty line before it
    const prefix = '\n\n';
    // Ensure closing $$ has empty line after it (if there's more content)
    const suffix = after === '\n' ? '\n\n' : '\n';
    return `${prefix}${open}\n${content.trim()}\n${close}${suffix}`;
  });
  
  return result;
}

// Render Markdown to HTML
const processedContent = preprocessMathBlocks(content);
const contentHtml = await marked.parse(processedContent);
---

<MarkdownLayout frontmatter={frontmatter}>
  <div set:html={contentHtml} />
</MarkdownLayout>