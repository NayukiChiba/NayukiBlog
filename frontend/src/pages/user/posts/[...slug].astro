---
// ğŸš€ é™æ€é¢„æ¸²æŸ“ï¼šæ„å»ºæ—¶ç”Ÿæˆæ‰€æœ‰æ–‡ç« é¡µé¢
export const prerender = true;

import fs from "node:fs/promises";
import path from "node:path";
import matter from "gray-matter";
import { marked } from "marked";
import katex from "katex";
import MarkdownLayout from "../../../layouts/MarkdownLayout.astro";

// æ„å»ºæ—¶è·å–æ‰€æœ‰æ–‡ç« è·¯å¾„
export async function getStaticPaths() {
    // ç¡®å®šå†…å®¹ç›®å½•
    let contentDir = path.join(process.cwd(), "blog");
    try {
        await fs.access(contentDir);
    } catch {
        contentDir = path.join(process.cwd(), "frontend/blog");
    }

    // é€’å½’è·å–æ‰€æœ‰ .md å’Œ .mdx æ–‡ä»¶
    async function getAllMarkdownFiles(
        dir: string,
        baseDir: string = dir,
    ): Promise<string[]> {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        const files: string[] = [];

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                files.push(...(await getAllMarkdownFiles(fullPath, baseDir)));
            } else if (
                entry.name.endsWith(".md") ||
                entry.name.endsWith(".mdx")
            ) {
                // è·å–ç›¸å¯¹äº baseDir çš„è·¯å¾„ï¼Œå¹¶ç§»é™¤æ‰©å±•å
                const relativePath = path.relative(baseDir, fullPath);
                const slug = relativePath
                    .replace(/\.(md|mdx)$/, "")
                    .replace(/\\/g, "/");
                files.push(slug);
            }
        }

        return files;
    }

    let slugs: string[] = [];
    try {
        slugs = await getAllMarkdownFiles(contentDir);
    } catch (e) {
        console.error("Failed to read blog directory:", e);
    }

    return slugs.map((slug) => ({
        params: { slug },
    }));
}

// è·å–å½“å‰æ–‡ç« çš„ slug
const { slug } = Astro.params;
const decodedSlug = decodeURIComponent(slug || "");

// ç¡®å®šå†…å®¹ç›®å½•
let contentDir = path.join(process.cwd(), "blog");
try {
    await fs.access(contentDir);
} catch {
    contentDir = path.join(process.cwd(), "frontend/blog");
}

// å°è¯•è¯»å– .md æˆ– .mdx æ–‡ä»¶
let filePath = path.join(contentDir, `${decodedSlug}.md`);
let fileContent = "";

try {
    try {
        fileContent = await fs.readFile(filePath, "utf-8");
    } catch (e) {
        // å°è¯• .mdx æ‰©å±•å
        filePath = path.join(contentDir, `${decodedSlug}.mdx`);
        fileContent = await fs.readFile(filePath, "utf-8");
    }
} catch (e) {
    console.error(`Post not found: ${decodedSlug}`, e);
    // é™æ€æ¨¡å¼ä¸‹æ— æ³•ä½¿ç”¨ redirectï¼Œè¿”å›ç©ºå†…å®¹
    fileContent =
        "---\ntitle: 404\ndate: 2024-01-01\n---\n\n# æ–‡ç« æœªæ‰¾åˆ°\n\nè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®ã€‚";
}

// è§£æ frontmatter å’Œå†…å®¹
const { data: frontmatter, content } = matter(fileContent);

// é…ç½® marked æ¸²æŸ“å™¨
const renderer = new marked.Renderer();

// ç®€å•ä»£ç å—æ¸²æŸ“ï¼ˆå®¢æˆ·ç«¯é«˜äº®ç”± Prism/highlight.js CDN å¤„ç†ï¼‰
renderer.code = ({ text, lang }) => {
    const language = lang || "plaintext";
    const escaped = text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    return `<pre class="astro-code language-${language}"><code class="language-${language}">${escaped}</code></pre>`;
};

// é…ç½® marked é€‰é¡¹
marked.use({
    renderer,
    gfm: true,
    breaks: false,
});

// ä½¿ç”¨ KaTeX æ¸²æŸ“æ•°å­¦å…¬å¼
function renderMath(latex: string, displayMode: boolean): string {
    try {
        return katex.renderToString(latex, {
            displayMode,
            throwOnError: false,
            trust: true,
            strict: false,
        });
    } catch (e) {
        console.error("KaTeX render error:", e);
        return displayMode
            ? `<div class="katex-error">$$${latex}$$</div>`
            : `<span class="katex-error">$${latex}$</span>`;
    }
}

// é¢„å¤„ç†ï¼šæå–å¹¶æ¸²æŸ“æ•°å­¦å…¬å¼ï¼Œç”¨å ä½ç¬¦æ›¿æ¢
function processMathFormulas(text: string): string {
    // è§„èŒƒåŒ–æ¢è¡Œç¬¦
    let result = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

    const mathBlocks: { placeholder: string; html: string }[] = [];
    let counter = 0;

    // å…ˆå¤„ç†å—çº§å…¬å¼ $$ ... $$ï¼ˆå¤šè¡Œï¼‰
    result = result.replace(/\$\$([\s\S]*?)\$\$/g, (match, latex) => {
        const placeholder = `%%MATH_BLOCK_${counter}%%`;
        const html = renderMath(latex.trim(), true);
        mathBlocks.push({ placeholder, html });
        counter++;
        return placeholder;
    });

    // å†å¤„ç†è¡Œå†…å…¬å¼ $ ... $ï¼ˆå•è¡Œï¼Œä¸åŒ…å«æ¢è¡Œï¼‰
    result = result.replace(/\$([^\$\n]+?)\$/g, (match, latex) => {
        const placeholder = `%%MATH_INLINE_${counter}%%`;
        const html = renderMath(latex.trim(), false);
        mathBlocks.push({ placeholder, html });
        counter++;
        return placeholder;
    });

    // è¿”å›å¤„ç†åçš„æ–‡æœ¬å’Œå ä½ç¬¦æ˜ å°„
    return JSON.stringify({ text: result, mathBlocks });
}

// è¿˜åŸæ•°å­¦å…¬å¼å ä½ç¬¦
function restoreMathFormulas(
    html: string,
    mathBlocks: { placeholder: string; html: string }[],
): string {
    let result = html;
    for (const block of mathBlocks) {
        result = result.replace(block.placeholder, block.html);
    }
    return result;
}

// æ¸²æŸ“ Markdown ä¸º HTML
const mathResult = JSON.parse(processMathFormulas(content));
const processedContent = mathResult.text;
const mathBlocks = mathResult.mathBlocks;

const rawHtml = await marked.parse(processedContent);
const contentHtml = restoreMathFormulas(rawHtml, mathBlocks);
---

<MarkdownLayout frontmatter={frontmatter}>
    <div set:html={contentHtml} />
</MarkdownLayout>
