---
// ğŸš€ é™æ€é¢„æ¸²æŸ“ï¼šæ„å»ºæ—¶ç”Ÿæˆæ‰€æœ‰æ–‡ç« é¡µé¢
export const prerender = true;

import fs from "node:fs/promises";
import path from "node:path";
import matter from "gray-matter";
import { marked } from "marked";
import MarkdownLayout from "../../../layouts/MarkdownLayout.astro";

// æ„å»ºæ—¶è·å–æ‰€æœ‰æ–‡ç« è·¯å¾„
export async function getStaticPaths() {
    // ç¡®å®šå†…å®¹ç›®å½•
    let contentDir = path.join(process.cwd(), "blog");
    try {
        await fs.access(contentDir);
    } catch {
        contentDir = path.join(process.cwd(), "frontend/blog");
    }

    // é€’å½’è·å–æ‰€æœ‰ .md å’Œ .mdx æ–‡ä»¶
    async function getAllMarkdownFiles(
        dir: string,
        baseDir: string = dir,
    ): Promise<string[]> {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        const files: string[] = [];

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                files.push(...(await getAllMarkdownFiles(fullPath, baseDir)));
            } else if (
                entry.name.endsWith(".md") ||
                entry.name.endsWith(".mdx")
            ) {
                // è·å–ç›¸å¯¹äº baseDir çš„è·¯å¾„ï¼Œå¹¶ç§»é™¤æ‰©å±•å
                const relativePath = path.relative(baseDir, fullPath);
                const slug = relativePath
                    .replace(/\.(md|mdx)$/, "")
                    .replace(/\\/g, "/");
                files.push(slug);
            }
        }

        return files;
    }

    let slugs: string[] = [];
    try {
        slugs = await getAllMarkdownFiles(contentDir);
    } catch (e) {
        console.error("Failed to read blog directory:", e);
    }

    return slugs.map((slug) => ({
        params: { slug },
    }));
}

// è·å–å½“å‰æ–‡ç« çš„ slug
const { slug } = Astro.params;
const decodedSlug = decodeURIComponent(slug || "");

// ç¡®å®šå†…å®¹ç›®å½•
let contentDir = path.join(process.cwd(), "blog");
try {
    await fs.access(contentDir);
} catch {
    contentDir = path.join(process.cwd(), "frontend/blog");
}

// å°è¯•è¯»å– .md æˆ– .mdx æ–‡ä»¶
let filePath = path.join(contentDir, `${decodedSlug}.md`);
let fileContent = "";

try {
    try {
        fileContent = await fs.readFile(filePath, "utf-8");
    } catch (e) {
        // å°è¯• .mdx æ‰©å±•å
        filePath = path.join(contentDir, `${decodedSlug}.mdx`);
        fileContent = await fs.readFile(filePath, "utf-8");
    }
} catch (e) {
    console.error(`Post not found: ${decodedSlug}`, e);
    // é™æ€æ¨¡å¼ä¸‹æ— æ³•ä½¿ç”¨ redirectï¼Œè¿”å›ç©ºå†…å®¹
    fileContent =
        "---\ntitle: 404\ndate: 2024-01-01\n---\n\n# æ–‡ç« æœªæ‰¾åˆ°\n\nè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®ã€‚";
}

// è§£æ frontmatter å’Œå†…å®¹
const { data: frontmatter, content } = matter(fileContent);

// é…ç½® marked æ¸²æŸ“å™¨
const renderer = new marked.Renderer();

// ç®€å•ä»£ç å—æ¸²æŸ“ï¼ˆå®¢æˆ·ç«¯é«˜äº®ç”± Prism/highlight.js CDN å¤„ç†ï¼‰
renderer.code = ({ text, lang }) => {
    const language = lang || "plaintext";
    const escaped = text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    return `<pre class="astro-code language-${language}"><code class="language-${language}">${escaped}</code></pre>`;
};

// é…ç½® marked é€‰é¡¹
// KaTeX å’Œä»£ç é«˜äº®éƒ½æ”¹ä¸ºå®¢æˆ·ç«¯ CDN æ¸²æŸ“
marked.use({
    renderer,
    gfm: true,
    breaks: false,
});

// é¢„å¤„ç†æ•°å­¦å…¬å¼å—
function preprocessMathBlocks(text: string): string {
    // è§„èŒƒåŒ–æ¢è¡Œç¬¦
    let result = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

    // ä¿®å¤å†…è”æ•°å­¦å…¬å¼åç´§è·Ÿæ‹¬å·çš„æƒ…å†µ
    result = result.replace(/\$([^$\n]+)\$\(/g, "$$$$1$$ (");

    // å¤„ç† $$ å—ï¼šç¡®ä¿å‰åæœ‰ç©ºè¡Œ
    result = result.replace(
        /(\n)(\$\$)\n([\s\S]*?)\n(\$\$)(\n|$)/g,
        (match, before, open, content, close, after) => {
            const prefix = "\n\n";
            const suffix = after === "\n" ? "\n\n" : "\n";
            return `${prefix}${open}\n${content.trim()}\n${close}${suffix}`;
        },
    );

    return result;
}

// æ¸²æŸ“ Markdown ä¸º HTML
const processedContent = preprocessMathBlocks(content);
const contentHtml = await marked.parse(processedContent);
---

<MarkdownLayout frontmatter={frontmatter}>
    <div set:html={contentHtml} />
</MarkdownLayout>
